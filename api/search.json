[{"id":"a7fb576f585a285d0be31f11b996bbe0","title":"Vue3中的插槽源码","content":"dome我们先来看个常见的插槽demo，其中子组件代码如下：\n12345678910&lt;template&gt;  &lt;slot&gt;&lt;/slot&gt;  &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;  &lt;slot name=&quot;footer&quot; :desc=&quot;desc&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const desc = ref(&quot;footer desc&quot;);&lt;/script&gt;\n\n在子组件中我们定义了三个插槽，第一个是默认插槽，第二个是name为header的插槽，第三个是name为footer的插槽，并且将desc变量传递给了父组件。\n我们再来看看父组件代码如下：\n123456789101112131415&lt;template&gt;  &lt;ChildDemo&gt;    &lt;p&gt;default slot&lt;/p&gt;    &lt;template v-slot:header&gt;      &lt;p&gt;header slot&lt;/p&gt;    &lt;/template&gt;    &lt;template v-slot:footer=&quot;&#123; desc &#125;&quot;&gt;      &lt;p&gt;footer slot: &#123;&#123; desc &#125;&#125;&lt;/p&gt;    &lt;/template&gt;  &lt;/ChildDemo&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import ChildDemo from &quot;./child.vue&quot;;&lt;/script&gt;\n\n来看看编译后的父组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123;  createBlock as _createBlock,  createElementVNode as _createElementVNode,  openBlock as _openBlock,  toDisplayString as _toDisplayString,  withCtx as _withCtx,&#125; from &quot;/node_modules/.vite/deps/vue.js?v=64ab5d5e&quot;;const _sfc_main = /* @__PURE__ */ _defineComponent(&#123;  // ...省略&#125;);function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (    _openBlock(),    _createBlock($setup[&quot;ChildDemo&quot;], null, &#123;      header: _withCtx(        () =&gt;          _cache[0] ||          (_cache[0] = [            _createElementVNode(              &quot;p&quot;,              null,              &quot;header slot&quot;,              -1              /* HOISTED */            ),          ])      ),      footer: _withCtx((&#123; desc &#125;) =&gt; [        _createElementVNode(          &quot;p&quot;,          null,          &quot;footer slot: &quot; + _toDisplayString(desc),          1          /* TEXT */        ),      ]),      default: _withCtx(() =&gt; [        _cache[1] ||          (_cache[1] = _createElementVNode(            &quot;p&quot;,            null,            &quot;default slot&quot;,            -1            /* HOISTED */          )),      ]),      _: 1,      /* STABLE */    &#125;)  );&#125;export default /* @__PURE__ */ _export_sfc(_sfc_main, [  [&quot;render&quot;, _sfc_render],]);\n\n在父组件中插槽经过编译后会变成一堆由插槽name组成的方法，执行这些方法就会生成插槽对应的虚拟DOM。默认插槽就是default方法，方法接收的参数就是子组件中插槽给父组件传递的变量\n编译后的子组件12345678910111213141516171819202122232425262728import &#123;  createElementBlock as _createElementBlock,  Fragment as _Fragment,  openBlock as _openBlock,  renderSlot as _renderSlot,&#125; from &quot;/node_modules/.vite/deps/vue.js?v=64ab5d5e&quot;;const _sfc_main = &#123;  // ...省略&#125;;function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (    _openBlock(),    _createElementBlock(      _Fragment,      null,      [        _renderSlot(_ctx.$slots, &quot;default&quot;),        _renderSlot(_ctx.$slots, &quot;header&quot;),        _renderSlot(_ctx.$slots, &quot;footer&quot;, &#123; desc: $setup.desc &#125;),      ],      64 /* STABLE_FRAGMENT */    )  );&#125;export default /*#__PURE__*/ _export_sfc(_sfc_main, [[&quot;render&quot;, _sfc_render]]);\n\n子组件中的插槽实际就是在执行父组件插槽对应的方法，在执行方法时可以将子组件的变量传递给父组件，这就是作用域插槽的原理。\n","slug":"Vue3中的插槽源码","date":"2025-03-07T06:15:50.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"23b6e0ae5d6dee99687505d16c2a98a4","title":"monorepo架构 前端项目管理模式","content":"monorepo架构 前端项目管理模式项目管理模式在当下大型前端项目中基于 monorepo 的解决方案已经深入人心，无论是比如 Google、Facebook，社区内部知名的开源项目 Babel、Vue-next ，还是集团中 rax-components 等等，都使用了 monorepo 方案来管理他们的代码。\n两大策略–Monorepo（单体仓库）与 MultiRepo（多仓库）\nMultirepo是由多个仓库组成的项目管理方式，每个仓库有着独立的工作流、组件与配置\nMonorepo则将不同仓库整合成为一个仓库，并共享工作流、组件与配置。\n\n\n\n\n场景\nMultiRepo\nMonoRepo\n\n\n\n代码可见性\n✅ 代码隔离，研发者只需关注自己负责的仓库 ❌ 包管理按照各自owner划分，当出现问题时，需要到依赖包中进行判断并解决。\n✅ 一个仓库中多个相关项目，很容易看到整个代码库的变化趋势，更好的团队协作。 ❌ 增加了非owner改动代码的风险\n\n\n依赖管理\n❌ 多个仓库都有自己的 node_modules，存在依赖重复安装情况，占用磁盘内存大。\n✅ 多项目代码都在一个仓库中，相同版本依赖提升到顶层只安装一次，节省磁盘内存，\n\n\n代码权限\n✅ 各项目单独仓库，不会出现代码被误改的情况，单个项目出现问题不会影响其他项目。\n❌ 多个项目代码都在一个仓库中，没有项目粒度的权限管控，一个项目出问题，可能影响所有项目。\n\n\n开发迭代\n✅ 仓库体积小，模块划分清晰，可维护性强。 ❌ 多仓库来回切换（编辑器及命令行），项目多的话效率很低。多仓库见存在依赖时，需要手动 npm link，操作繁琐。 ❌ 依赖管理不便，多个依赖可能在多个仓库中存在不同版本，重复安装，npm link 时不同项目的依赖会存在冲突。\n✅ 多个项目都在一个仓库中，可看到相关项目全貌，编码非常方便。 ✅ 代码复用高，方便进行代码重构。 ❌ 多项目在一个仓库中，代码体积多大几个 G，git clone时间较长。 ✅ 依赖调试方便，依赖包迭代场景下，借助工具自动 npm link，直接使用最新版本依赖，简化了操作流程。\n\n\n工程配置\n❌ 各项目构建、打包、代码校验都各自维护，不一致时会导致代码差异或构建差异。\n✅ 多项目在一个仓库，工程配置一致，代码质量标准及风格也很容易一致。\n\n\n构建部署\n❌ 多个项目间存在依赖，部署时需要手动到不同的仓库根据先后顺序去修改版本及进行部署，操作繁琐效率低。\n✅ 构建性 Monorepo 工具可以配置依赖项目的构建优先级，可以实现一次命令完成所有的部署。\n\n\n总结总结来说， monorepo 倾向于增强协作和代码一致性，而 multirepo 则更强调项目独立性和简单性。选择哪种模式取决于具体团队规模、项目间关联程度、基础设施支持等因素。\n在github上我们可以看见无论是 element plus 、 Ant design 以及 vue ，以及其他社区开源的项目都是使用的 monorepo 方案来管理他们的项目\n","slug":"monorepo架构 前端项目管理模式","date":"2025-03-07T06:06:50.000Z","categories_index":"其他","tags_index":"其他","author_index":"权栈"},{"id":"0b4427dd59aaa64311629076103363d5","title":"Git提交规范 提交信息验证","content":"背景介绍项目中代码格式以及git message如果不加以约束，可能最终的格式会五花八门，这样很不利于项目维护，好的提交记录，会将每次提交内容的范围，内容，以及涉及到的 bug 都能清晰的展示出来，且格式一致，便于查找找提交记录，对查看代码提交记录或者审核的人更友好，能够更好地了解项目的生命周期以及中间出现的问题。\nCommit message 格式为了方便使用，我们避免了过于复杂的规定，格式较为简单且不限制中英文：\n123&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 注意冒号 : 后有空格// 如 feat(miniprogram): 增加了小程序模板消息相关功能\n\nscope选填表示commit的作用范围，如数据层、视图层，也可以是目录名称 subject必填用于对commit进行简短的描述 type必填表示提交类型，值有以下几种：\n\nfeat - 新功能 feature\nfix - 修复 bug\ndocs - 文档注释\nstyle - 代码格式(不影响代码运行的变动)\nrefactor - 重构、优化(既不增加新功能，也不是修复bug)\nperf - 性能优化\ntest - 增加测试\nchore - 构建过程或辅助工具的变动\nrevert - 回退\nbuild - 打包\n\n如何加入项目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// commitlint// 项目目录下安装npm i commitlint --save-devnpm i @commitlint/config-conventional --save-dev// 在项目目录下，新建配置文件 commitlint.config.js， 内容如下module.exports = &#123;  extends: [&#x27;@commitlint/config-conventional&#x27;],  rules: &#123;    // \btype 类型定义    &#x27;type-enum&#x27;: [2, &#x27;always&#x27;, [      &quot;feat&quot;, // 新功能 feature      &quot;fix&quot;, // 修复 bug      &quot;docs&quot;, // 文档注释      &quot;style&quot;, // 代码格式(不影响代码运行的变动)      &quot;refactor&quot;, // 重构(既不增加新功能，也不是修复bug)      &quot;perf&quot;, // 性能优化      &quot;test&quot;, // 增加测试      &quot;chore&quot;, // 构建过程或辅助工具的变动      &quot;revert&quot;, // 回退      &quot;build&quot; // 打包    ]],    // subject 大小写不做校验    // 自动部署的BUILD ROBOT的commit信息大写，以作区别    &#x27;subject-case&#x27;: [0]  &#125;&#125;;// husky// 项目目录下安装npm i husky --save-dev// 在package.json文件中增加相关配置&quot;husky&quot;: &#123;  &quot;hooks&quot;: &#123;    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;  &#125;&#125;// commitizen// 全局安装npm install commitizen -g// 项目目录下安装npm install commitizen --save-devcommitizen init cz-customizable --save --save-exact// 在package.json文件中增加相关配置&quot;config&quot;: &#123;  &quot;commitizen&quot;: &#123;    &quot;path&quot;: &quot;./node_modules/cz-customizable&quot;  &#125;&#125;// 在项目目录下，新建配置文件 .cz-config.js&#x27;use strict&#x27;;module.exports = &#123;  types: [    &#123;value: &#x27;feat&#x27;,     name: &#x27;feat:     新功能&#x27;&#125;,    &#123;value: &#x27;fix&#x27;,      name: &#x27;fix:      修复&#x27;&#125;,    &#123;value: &#x27;docs&#x27;,     name: &#x27;docs:     文档变更&#x27;&#125;,    &#123;value: &#x27;style&#x27;,    name: &#x27;style:    代码格式(不影响代码运行的变动)&#x27;&#125;,    &#123;value: &#x27;refactor&#x27;, name: &#x27;refactor: 重构(既不是增加feature，也不是修复bug)&#x27;&#125;,    &#123;value: &#x27;perf&#x27;,     name: &#x27;perf:     性能优化&#x27;&#125;,    &#123;value: &#x27;test&#x27;,     name: &#x27;test:     增加测试&#x27;&#125;,    &#123;value: &#x27;chore&#x27;,    name: &#x27;chore:    构建过程或辅助工具的变动&#x27;&#125;,    &#123;value: &#x27;revert&#x27;,   name: &#x27;revert:   回退&#x27;&#125;,    &#123;value: &#x27;build&#x27;,    name: &#x27;build:    打包&#x27;&#125;  ],  // override the messages, defaults are as follows  messages: &#123;    type: &#x27;请选择提交类型:&#x27;,    // scope: &#x27;请输入文件修改范围(可选):&#x27;,    // used if allowCustomScopes is true    customScope: &#x27;请输入修改范围(可选):&#x27;,    subject: &#x27;请简要描述提交(必填):&#x27;,    body: &#x27;请输入详细描述(可选，待优化去除，跳过即可):&#x27;,    // breaking: &#x27;List any BREAKING CHANGES (optional):\\n&#x27;,    footer: &#x27;请输入要关闭的issue(待优化去除，跳过即可):&#x27;,    confirmCommit: &#x27;确认使用以上信息提交？(y/n/e/h)&#x27;  &#125;,  allowCustomScopes: true,  // allowBreakingChanges: [&#x27;feat&#x27;, &#x27;fix&#x27;],  skipQuestions: [&#x27;body&#x27;, &#x27;footer&#x27;],  // limit subject length, commitlint默认是72  subjectLimit: 72&#125;;\n\n检测提交信息该流程用于校验提交信息的写入是否符合规则要求。\n安装依赖\n1npm install ghooks  validate-commit-msg --save-dev\n\npackage.json配置\n12345&quot;config&quot;: &#123;    &quot;ghooks&quot;: &#123;      &quot;commit-msg&quot;: &quot;validate-commit-msg&quot;    &#125;&#125;\n\n配置完成后其他人如何使用\n将配置测试完成的代码合并至主分支。\n其他开发者需要重新执行 npm i安装相关依赖。\n需要全局安装 npm i commitizen -g\n\n如何使用12git add --allgit cz\n\n效果\n","slug":"Git提交规范 提交信息验证","date":"2025-01-17T06:08:50.000Z","categories_index":"其他","tags_index":"其他","author_index":"权栈"},{"id":"bda55ba4f6f13ee1e9f8f3091a69e603","title":"前端项目协同开发统一代码格式化","content":"问题背景现有业务项目中，开发人员使用的ide五花八门，既有Visual Studio Code、webstorm，也有idea、pycharm这种偏后端的ide；而且各自设置的code style也不一致，为了统一团队风格，减少后期代码维护量，决定进行整改。\n1.前端开发人员修改此操作要 “前端负责人修改项目”完成之后才能操作使用\n1.1Vscod第一步 现有主流的前端格式化工具是prettier，需要进行安装和配置。\n\n第二步 将鼠标光标挪至页面空白处，右键，于浮现的菜单里选中 “使用格式化文档” 。\n\n第三步 选中 Prettier-Code formatter 设置成默认值\n\n第四步 执行保存动作后，若文档格式发生变化，就意味着保存成功。倘若未能成功，请参照下述步骤进行排查。\n\n 第五步 勾选 “Format On Paste” 和 “Format On Save” 这两个选项，完成勾选操作之后，请重启软件，以确保新的设置正常运行。\n\n1.2 Webstorm第一步  现有主流的前端格式化工具是prettier，需要进行安装和配置。\n\n第二步 安装完插件进行以下配置，配置完成需要重启编辑器\n\n第三步  文件代码发生变化之后执行保存动作，若文档格式发生变化，就意味着保存成功。倘若未能成功，请参照下述步骤进行排查。\n\n2. 前端负责人修改项目项目内安装Prettier：在项目目录下运行 npm install prettier –save-dev 来安装Prettier作为开发依赖。 创建Prettier配置文件：在项目根目录下创建一个.prettierrc 文件。\n12345678910111213141516171819202122232425262728293031323334&#123;\t&quot;printWidth&quot;: 150,\t&quot;tabWidth&quot;: 4,\t&quot;useTabs&quot;: true,\t&quot;singleQuote&quot;: true,\t&quot;quoteProps&quot;: &quot;as-needed&quot;,\t&quot;trailingComma&quot;: &quot;none&quot;,\t&quot;bracketSpacing&quot;: true,\t&quot;jsxBracketSameLine&quot;: false,\t&quot;arrowParens&quot;: &quot;always&quot;,\t&quot;rangeStart&quot;: 0,\t&quot;requirePragma&quot;: false,\t&quot;insertPragma&quot;: false,\t&quot;proseWrap&quot;: &quot;preserve&quot;,\t&quot;htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;,\t&quot;vueIndentScriptAndStyle&quot;: false,\t&quot;endOfLine&quot;: &quot;auto&quot;,\t&quot;semi&quot;: false,\t&quot;usePrettierrc&quot;: true,\t&quot;overrides&quot;: [\t\t&#123;\t\t\t&quot;files&quot;: &quot;*.json&quot;,\t\t\t&quot;options&quot;: &#123;\t\t\t\t&quot;tabWidth&quot;: 4\t\t\t&#125;\t\t&#125;,\t\t&#123;\t\t\t&quot;files&quot;: &quot;*.md&quot;,\t\t\t&quot;options&quot;: &#123;\t\t\t\t&quot;printWidth&quot;: 100\t\t\t&#125;\t\t&#125;\t]&#125;\n\n3.一键格式化整个项目在package.json添加一键格式化所有代码的脚本\n1&quot;prettier&quot;: &quot;prettier --config ./.prettierrc --write \\&quot;./src/**/*.&#123;js,jsx,vue&#125;\\&quot; &quot;\n\n","slug":"前端项目协同开发统一代码格式化","date":"2025-01-17T06:01:50.000Z","categories_index":"其他","tags_index":"其他","author_index":"权栈"},{"id":"9362a9fd3d9a6f67374a66848577cfe7","title":"函数柯里化","content":"什么是柯里化先给出函数柯里化的定义 ：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n例子\n1234function sum(a, b, c) &#123;  console.log(a + b + c);&#125;sum(1, 2, 3); // 6\n\n这个是一个累加函数，接收三个参数，但是假设我有这样一种需求就是前两个参数不变，然后最后一个参数可以随意。\n很多人，第一想法就是传入前两个不改不就行了。其实这个也能说是一个解决方案，但是代码得优雅，经常一调用就得穿前面那俩个固定的参数是不是很繁琐而且容易出错，出错之后还不好排查，对吧。\n再去分析这个需求，咱们先不管函数的具体实现，这个需求的调用写法sum(1, 2)(3);这样 sum(1, 2)(10); 。就是，先把前 2 个参数的运算结果拿到后，再与第 3 个参数相加。这个就是函数柯里化的简单应用\n柯里化实现sum(1, 2)(3); 这样的写法，并不常见。拆开来看，sum(1, 2) 返回的应该还是个函数，因为后面还有 (3) 需要执行。其实你会发现sum(1,2)其实是不是返回的就是一个函数，然后函数在调用传参才返回的最终结果。 然后反过来，从最后一个参数，从右往左看，它的左侧必然是一个函数。以此类推，如果前面有 n 个()，那就是有 n 个函数返回了结果，只是返回的结果，还是一个函数。是不是有点递归的意思？\n123456789101112131415161718function curry(fn) &#123;  return function curried(...args) &#123;    if (args.length &gt;= fn.length) &#123;      return fn(...args);    &#125; else &#123;      return function (...moreArgs) &#123;        return curried(...args, ...moreArgs);      &#125;;    &#125;  &#125;;&#125;function add(a, b, c) &#123;  return a + b + c;&#125;const curriedAdd = curry(add);console.log(curriedAdd(1)(2)(3)); // 6\n\n函数的柯里化，是 JavaScript 中函数式编程的一个重要概念。它返回的，是一个函数的函数。其实现方式，需要依赖参数以及递归，通过拆分参数的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。\n","slug":"函数柯里化","date":"2025-01-10T07:50:20.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"29983d06ba41eaf724125282c4708e00","title":"setTimeout不准时?","content":"演示使用一个计数器来记录每次 setTimeout 的调用。设定的间隔时间乘以计数次数，理想情况下应等于预期的延迟。通过以下示例，可以检查我们计时器的准确性。\n12345678910111213141516171819202122232425262728function time() &#123;  var speed = 50, // 间隔    count = 1; // 计数  start = new Date().getTime();  function instance() &#123;    var ideal = count * speed,      real = new Date().getTime() - start;    count++;    console.log(count + &quot;理想值------------------------：&quot;, ideal); // 记录理想值    console.log(count + &quot;真实值------------------------：&quot;, real); // 记录理想值    var diff = real - ideal;    console.log(count + &quot;差值------------------------：&quot;, diff); // 差值    // 小于5执行    if (count &lt; 5) &#123;      window.setTimeout(function () &#123;        instance();      &#125;, speed);    &#125;  &#125;  window.setTimeout(function () &#123;    instance();  &#125;, speed);&#125;\n\n打印 12 理想值————————： 502 真实值————————： 592 差值————————： 93 理想值————————： 1003 真实值————————： 1263 差值————————： 264 理想值————————： 1504 真实值————————： 1804 差值————————： 305 理想值————————： 2005 真实值————————： 2325 差值————————： 32\n我们可以在 setTimeout 执行之前加入额外的代码逻辑，然后再观察这个差值。\n123456789...window.setTimeout(function()&#123;    instance();&#125;, speed);for(var a = 1, i = 0; i &lt; 10000000; i++) &#123;    a *= (i + 1);&#125;;...\n\n2 理想值————————： 502 真实值————————： 622 差值————————： 123 理想值————————： 1003 真实值————————： 1223 差值————————： 224 理想值————————： 1504 真实值————————： 1744 差值————————： 245 理想值————————： 2005 真实值————————： 2285 差值————————： 28\nsetTimeout 系统时间补偿当每一次定时器执行时后，都去获取系统的时间来进行修正，虽然每次运行可能会有误差，但是通过系统时间对每次运行的修复，能够让后面每一次时间都得到一个补偿。\n12345678910111213141516171819202122232425262728function time() &#123;  var speed = 50, // 间隔    count = 1; // 计数  start = new Date().getTime();  function instance() &#123;    var ideal = count * speed,      real = new Date().getTime() - start;    count++;    console.log(count + &quot;理想值------------------------：&quot;, ideal); // 记录理想值    console.log(count + &quot;真实值------------------------：&quot;, real); // 记录理想值    var diff = real - ideal;    console.log(count + &quot;差值------------------------：&quot;, diff); // 差值    // 5次后不再执行    if (count &lt; 5) &#123;      window.setTimeout(function () &#123;        instance();      &#125;, speed - diff);    &#125;  &#125;  window.setTimeout(function () &#123;    instance();  &#125;, speed);&#125;\n","slug":"setTimeout不准时","date":"2025-01-03T05:52:50.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"6bbd855e83e27561534b81f565184962","title":"Vue3的provide和inject源码","content":"provide和inject函数是如何实现数据多级传递的。\n看个demo代码如下：\n123456789101112&lt;template&gt;  &lt;ChildDemo /&gt;&lt;/template&gt;&lt;script setup&gt;import ChildDemo from &quot;./child.vue&quot;;import &#123; ref, provide &#125; from &quot;vue&quot;;// 提供响应式的值const count = ref(0);provide(&quot;count&quot;, count);&lt;/script&gt;\n\n在父组件中使用provide为后代组件注入一个count响应式变量。\n再来看看子组件child.vue代码如下：\n1234567&lt;script setup&gt;import &#123; inject &#125; from &quot;vue&quot;;// 注入响应式的值const count = inject(&quot;count&quot;);console.log(&quot;inject count is:&quot;, count);&lt;/script&gt;\n\n从上面的代码可以看到在孙子组件中使用inject函数拿到了父组件中注入的count响应式变量。\nprovide函数1234567891011121314function provide(key, value) &#123;  if (!currentInstance) &#123;    if (!!(process.env.NODE_ENV !== &quot;production&quot;)) &#123;      warn$1(`provide() can only be used inside setup().`);    &#125;  &#125; else &#123;    let provides = currentInstance.provides;    const parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides;    if (parentProvides === provides) &#123;      provides = currentInstance.provides = Object.create(parentProvides);    &#125;    provides[key] = value;  &#125;&#125;\n\n首先判断currentInstance是否有值，如果没有就说明当前没有vue实例，也就是说当前调用provide函数的地方是不在setup函数中执行的，然后给出警告provide只能在setup中使用。\n然后走进else逻辑中，首先从当前vue实例中取出存的provides属性对象。并且通过currentInstance.parent.provides拿到父组件vue实例中的provides属性对象。\n这里为什么需要判断if (parentProvides === provides)呢？\n因为在创建子组件时会默认使用父组件的provides属性对象作为父组件的provides属性对象。代码如下：\n12345678const instance: ComponentInternalInstance = &#123;  uid: uid++,  vnode,  type,  parent,  provides: parent ? parent.provides : Object.create(appContext.provides),  // ...省略&#125;\t\n\n从上面的代码可以看到如果有父组件，那么创建子组件实例的时候就直接使用父组件的provides属性对象。\n所以这里在provide函数中需要判断if (parentProvides === provides)，如果相等说明当前父组件和子组件是共用的同一个provides属性对象。此时如果子组件调用了provide函数，说明子组件需要创建自己的provides属性对象。\n并且新的属性对象还需要能够访问到父组件中注入的内容，所以这里以父组件的provides属性对象为原型去创建一个新的子组件的，这样在子组件中不仅能够访问到原型链中注入的provides属性对象，也能够访问到自己注入进去的provides属性对象。\n最后就是执行provides[key] = value将当前注入的内容存到provides属性对象中。\ninject函数1234567891011121314151617181920212223242526272829303132export function inject(  key: InjectionKey&lt;any&gt; | string,  defaultValue?: unknown,  treatDefaultAsFactory = false,) &#123;  // fallback to `currentRenderingInstance` so that this can be called in  // a functional component  const instance = currentInstance || currentRenderingInstance  // also support looking up from app-level provides w/ `app.runWithContext()`  if (instance || currentApp) &#123;    const provides = currentApp      ? currentApp._context.provides      : instance        ? instance.parent == null          ? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides          : instance.parent.provides        : undefined    if (provides &amp;&amp; key in provides) &#123;      return provides[key]    &#125; else if (arguments.length &gt; 1) &#123;      return treatDefaultAsFactory &amp;&amp; isFunction(defaultValue)        ? defaultValue.call(instance &amp;&amp; instance.proxy)        : defaultValue    &#125; else if (__DEV__) &#123;      warn(`injection &quot;$&#123;String(key)&#125;&quot; not found.`)    &#125;  &#125; else if (__DEV__) &#123;    warn(`inject() can only be used inside setup() or functional components.`)  &#125;&#125;\n\n首先拿到当前渲染的vue实例赋值给本地变量instance。接着使用if (instance || currentApp)判断当前是否有vue实例，如果没有看看有没有使用app.runWithContext手动注入了上下文，如果注入了那么currentApp就有值。\n接着就是一串三元表达式，如果使用app.runWithContext手动注入了上下文，那么就优先从注入的上下文中取出provides属性对象。\n如果没有那么就看当前组件是否满足instance.parent == null，也就是说当前组件是否是根节点。如果是根节点就取app中注入的provides属性对象。\n如果上面的都不满足就去取父组件中注入的provides属性对象，前面我们讲过了在inject函数阶段，如果子组件内没有使用inject函数，那么就会直接使用父组件的provides属性对象。如果子组件中使用了inject函数，那么就以父组件的provides属性对象为原型去创建一个新的子组件的provides属性对象，从而形成一条原型链。\n所以这里的孙子节点的provides属性对象中当然就能够拿到父组件中注入的count响应式变量，那么if (provides &amp;&amp; key in provides)就满足条件，最后会走到return provides[key]中将父组件中注入的响应式变量count原封不动的返回。\n还有就是如果我们inject一个没有使用provide存入的key，并且传入了第二个参数defaultValue，此时else if (arguments.length &gt; 1)就满足条件了。\n在里面会去判断是否传入第三个参数treatDefaultAsFactory，如果这个参数的值为true，说明第二个参数defaultValue可能是一个工厂函数。那么就执行defaultValue.call(instance &amp;&amp; instance.proxy)将defaultValue的当中工厂函数的执行结果进行返回。\n如果第三个参数treatDefaultAsFactory的值不为true，那么就直接将第二个参数defaultValue当做默认值返回。\n总结在创建vue组件实例时，子组件的provides属性对象会直接使用父组件的provides属性对象。如果在子组件中使用了provide函数，那么会以父组件的provides属性对象为原型创建一个新的provides属性对象，并且将provide函数中注入的内容塞到新的provides属性对象中，从而形成了原型链。\n在孙子组件中，他的parent就是子组件。前面我们讲过了如果没有在组件内使用provide注入东西（很明显这里的子组件确实没有注入任何东西），那么就会直接使用他的父组件的provides属性对象，所以这里的子组件是直接使用的是父组件中的provides属性对象。所以在孙子组件中可以直接使用inject函数拿到父组件中注入的内容。\n","slug":"Vue3的provide和inject源码","date":"2024-12-27T04:32:10.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"0818b661b1c32ba6a0c1f1f3dba65b2c","title":"前端实现画中画","content":"Document Picture-in-Picture 介绍文档画中画 (Document Picture-in-Picture, 本文简称 PiP)。\n你可能已经在视频平台（如腾讯视频、哔哩哔哩等网页）见过这种效果：视频播放时，可以点击画中画后。无论你切换页面，它都始终显示在屏幕的最上层，\nHTML 基本代码结构1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document Picture-in-Picture API 示例&lt;/title&gt;    &lt;style&gt;      #pipContent &#123;        width: 600px;        height: 300px;        background: pink;        font-size: 20px;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;container&quot;&gt;      &lt;div id=&quot;pipContent&quot;&gt;这是一个将要放入画中画的 div 元素！&lt;/div&gt;      &lt;button id=&quot;clickBtn&quot;&gt;切换画中画&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;      // 在这里写你的 JavaScript 代码    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n请求 PiP 窗口PiP 的核心方法是 window.documentPictureInPicture.requestWindow。它是一个 异步方法，返回一个新创建的 window 对象。PIP 窗口可以将其看作一个新的网页，但它始终悬浮在屏幕上方。\n1234567891011121314document  .getElementById(&quot;clickBtn&quot;)  .addEventListener(&quot;click&quot;, async function () &#123;    // 获取将要放入 PiP 窗口的 DOM 元素    const pipContent = document.getElementById(&quot;pipContent&quot;);    // 请求创建一个 PiP 窗口    const pipWindow = await window.documentPictureInPicture.requestWindow(&#123;      width: 200, // 设置窗口的宽度      height: 300, // 设置窗口的高度    &#125;);    // 将原始元素添加到 PiP 窗口中    pipWindow.document.body.appendChild(pipContent);  &#125;);\n","slug":"前端实现画中画","date":"2024-12-20T06:05:06.787Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"13e59df8589be4afa367272d91271e61","title":"vue 实现关键字高亮效果","content":"vue 实现关键字高亮效果这是啥子意思呢，就是类似于百度搜索，根据关键词搜索结果，搜索结果中，与关键词相同的字显示红色，仅此而已，没有什么大的功能。简单写一下demo。\n1234567891011121314151617181920212223242526272829303132&lt;template&gt;  &lt;div class=&quot;ed-con&quot;&gt;    &lt;el-input v-model=&quot;input&quot; style=&quot;width: 240px&quot; placeholder=&quot;Please input&quot;/&gt;    &lt;p v-html=&quot;txt&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;;const input = ref(&#x27;&#x27;);const txt = ref(&#x27;在古老的小镇边缘，有一间被岁月温柔抚摸过的木屋，它静静地伫立在一片绚烂的野花丛中。屋内，住着一位名叫苏婉的女子，她拥有一双能洞察人心的眼睛和一头如夜色般深邃的长发。每天黄昏，苏婉都会坐在窗边，手捧一本泛黄的书，眼神时而凝重，时而温柔，仿佛在与书中人物进行着跨越时空的对话。\\n&#x27; +    &#x27;\\n&#x27; +    &#x27;某天，一阵突如其来的风雨打破了小镇的宁静，也吹散了苏婉心中的平静。一位浑身湿透的青年男子闯入了她的世界，带着一身未解之谜。苏婉望着他，眼中闪过一抹不易察觉的光芒，她知道，自己的生活从此将不再平凡。两人在雨后的木屋里，围绕着炉火，开始编织起一段关于寻找、救赎与爱的故事，而窗外的世界，正悄悄地为这段奇遇添上一抹神秘的色彩。&#x27;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.ed-con &#123;  width: 100%;  height: 100%;  padding: 20px;  box-sizing: border-box;  ::v-deep(.ed-highlight) &#123;    color: red;  &#125;&#125;&lt;/style&gt;\n\n接下来就是怎么实现输入框输入数据之后，下面的文字中，与关键字相同的文字高亮成红色的，很简单，就一个方法：\n123456789const highlightText = () =&gt; &#123;  if (!input.value) &#123;    return txt.value;  &#125;  const regex = new RegExp(`($&#123;input.value&#125;)`, &#x27;gi&#x27;);  const highlightedText = txt.value.replace(regex, &#x27;&lt;span class=&quot;ed-highlight&quot;&gt;$1&lt;/span&gt;&#x27;);  return highlightedText;&#125;\n\n然后再调用一下这个方法就可以了：\n1&lt;p v-html=&quot;highlightText()&quot;&gt;&lt;/p&gt;\n\n","slug":"vue 实现关键字高亮效果","date":"2024-11-29T06:23:50.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"权栈"},{"id":"da2d755c98b04089d7596f9ea22513af","title":"瀑布流","content":"什么是瀑布流瀑布流布局，作为一种现代网页设计中的创新布局方式，以其独特的视觉风格和流畅的用户体验在众多网站设计中脱颖而出。这种布局模式被形象地称为“瀑布流”\n瀑布流布局的核心特征多列等宽不等高：瀑布流布局以多列的形式展现内容，每列宽度保持一致，而高度则根据所容纳内容的大小动态调整，形成错落有致的视觉效果。\n动态加载与无限滚动：用户在浏览过程中，随着滚动页面，新的内容块会自动加载，实现了“无尽”的内容流，减少了分页操作，提升了浏览连贯性。\n视觉吸引力：尤其擅长展示图片或视觉元素丰富的媒体内容，为用户提供了沉浸式的浏览体验，增加了页面的观赏性和互动性。\n设计瀑布流布局\n先获取屏幕的大小\n获取图片的宽度\n确定第一行能放几张图（n张）\n操作第 n+1 张 摆放它的位置，将其放在高度最小的那一列\n获取每一列的高度\n放入图片后，更新这一列的高度\n\nHTML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;   &lt;style&gt;    *&#123;      margin: 0;      padding: 0;    &#125;    #container&#123;      position: relative;    &#125;    .box&#123;      float: left;      padding: 5px;    &#125;    .box-img&#123;      width: 150px;      padding: 5px;      border: 1px solid #aaa;    &#125;    img&#123;      width: 100%;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;box-img&quot;&gt;        &lt;img src=&quot;./img/1.webp&quot; alt=&quot;&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;    ···    ···    ···    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;box-img&quot;&gt;        &lt;img src=&quot;./img/9.webp&quot; alt=&quot;&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;box-img&quot;&gt;        &lt;img src=&quot;./img/10.webp&quot; alt=&quot;&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\njs1234567891011121314151617181920212223242526272829303132333435window.onload = function() &#123;    imgLocation(&#x27;container&#x27;, &#x27;box&#x27;)        function imgLocation(parent, child) &#123;      var cParent = document.getElementById(parent)      var cChild = cParent.getElementsByClassName(child)      var screenWidth = window.innerWidth      var imgWidth = cChild[0].offsetWidth      var num = Math.floor(screenWidth / imgWidth)      cParent.style.width = `$&#123;imgWidth * num&#125;px`        // 操作第 num+1 张      var boxHeightArr = []      for (var i = 0; i &lt; cChild.length; i++) &#123;        if (i &lt; num) &#123;  // 第一行          boxHeightArr.push(cChild[i].offsetHeight)        &#125;         else &#123;          // 找数组最小值          var minHeight = Math.min(...boxHeightArr)            var minIndex = boxHeightArr.indexOf(minHeight)             // 摆放图片          cChild[i].style.position = &#x27;absolute&#x27;          cChild[i].style.top = minHeight + &#x27;px&#x27;          cChild[i].style.left = cChild[minIndex].offsetLeft + &#x27;px&#x27;            // 更新这一列的高度          boxHeightArr[minIndex] = boxHeightArr[minIndex] + cChild[i].offsetHeight        &#125;      &#125;    &#125;    &#125;\n\nwindow.onload = function() &#123;&#125;js 写在头部，加上这个就不影响了，之后的代码写在里面就可以了；\nimgLocation(&#39;container&#39;, &#39;box&#39;)   运用封装的思维\n.offsetWidth  获取宽度\n.offsetHeight 获取高度\n.offsetLeft   获取距离父元素的左侧距离\n.offsetTop    获取距离父元素的顶部距离\n...boxHeightArr   …是解构数组的操作\nindexof(arr)      会返回数组的下标\n","slug":"瀑布流","date":"2024-11-22T06:12:20.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"b78b732595416811105ff8bbead66711","title":"前端通信 CustomEvent","content":"通过简单的几行代码，我们能够轻松创建和触发自定义事件，从而降低特殊场景下的开发风险，并且提升我们的开发效率。而且它可以非常容易的写到 React 和 Vue 项目中，\n实现过程看看如何利用 CustomEvent 构建一个全局广播推送消息的机制：\n1234567// 创建并触发自定义事件const customEvent = w(&#x27;yourEventName&#x27;, &#123;    detail: &#123; key: &#x27;myKey&#x27;, value: &#x27;newValue&#x27;&#125; // 自定义数据&#125;); window.dispatchEvent(customEvent); // 推送消息\n\n我们需要设置接收端：\n1234567// 监听自定义事件window.addEventListener(&#x27;yourEventName&#x27;, (event) =&gt; &#123;  const &#123; key, value &#125; = event.detail;  if (key === &#x27;myKey&#x27;) &#123;    console.log(&#x27;Detected localStorage change:&#x27;, value);  &#125;&#125;);\n\nVue 组件之间进行通信12345678910111213141516171819202122232425&lt;template&gt;  &lt;div&gt;    &lt;input v-model=&quot;username&quot; @input=&quot;updateUser&quot; placeholder=&quot;Enter your name&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      username: &#x27;&#x27;,    &#125;;  &#125;,  methods: &#123;    updateUser() &#123;      // 创建并触发自定义事件      const customEvent = new CustomEvent(&#x27;userUpdated&#x27;, &#123;        detail: &#123; name: this.username &#125;,      &#125;);      window.dispatchEvent(customEvent);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\nNotification.vue\n1234567891011121314151617181920212223&lt;template&gt;  &lt;div v-if=&quot;message&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;&#x27;,    &#125;;  &#125;,  mounted() &#123;    window.addEventListener(&#x27;userUpdated&#x27;, (event) =&gt; &#123;      const &#123; name &#125; = event.detail;      this.message = `User name has been changed to $&#123;name&#125;`;    &#125;);  &#125;,  beforeDestroy() &#123;    window.removeEventListener(&#x27;userUpdated&#x27;, this.eventListener);  &#125;,&#125;;&lt;/script&gt;\n\n","slug":"前端通信 CustomEvent","date":"2024-11-08T06:39:50.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"权栈"},{"id":"4a2d58310807e71f37ee94ffca6e1c5d","title":"在 Vue 中实现20MB图片上传压缩到10KB","content":"在现代 Web 应用中，文件上传是一个常见的功能，尤其是在用户需要上传图片时。然而，上传的文件往往会占用较大的存储空间，影响性能和用户体验。因此，限制文件大小是一个重要的需求。在这篇文章中，我们将介绍如何在 Vue.js 应用中实现文件上传，并将上传压缩到 10KB\n创建文件上传组件我们首先需要创建一个简单的文件上传组件，用户可以通过这个组件选择图片文件。以下是基本的组件结构：\n123456&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;file&quot; @change=&quot;handleFileUpload&quot; accept=&quot;image/*&quot; /&gt;    &lt;img v-if=&quot;imageSrc&quot; :src=&quot;imageSrc&quot; alt=&quot;Preview&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;\n\n这个模板包含一个文件输入框和一个用于显示图片预览的 img 标签。\n处理文件上传接下来，我们需要在组件中定义文件上传的逻辑。我们将使用 FileReader API 来读取文件，并通过 canvas 进行图片的压缩处理。\n123456789101112131415&lt;script&gt;export default &#123;  data() &#123;    return &#123;      imageSrc: null,    &#125;;  &#125;,  methods: &#123;    async handleFileUpload(event) &#123;      const file = event.target.files[0];      if (file) &#123;        const compressedFile = await this.compressImage(file);        console.log(compressedFile);      &#125;    &#125;,\n\nhandleFileUpload 方法会在用户选择文件后被调用。我们首先检查用户是否选择了文件，如果选择了，则调用 compressImage 方法进行压缩处理。\n压缩图片压缩图片的核心逻辑在于 compressImage 方法。该方法会创建一个新的 canvas 元素，并根据最大宽高对图片进行缩放，然后将其压缩到 10KB 以内。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849      compressImage(file) &#123;      return new Promise((resolve, reject) =&gt; &#123;        const reader = new FileReader();        reader.onload = (e) =&gt; &#123;          const img = new Image();          img.src = e.target.result;          img.onload = () =&gt; &#123;            const canvas = document.createElement(&#x27;canvas&#x27;);            const ctx = canvas.getContext(&#x27;2d&#x27;);            const MAX_WIDTH = 100; // 最大宽度            const MAX_HEIGHT = 100; // 最大高度            let width = img.width;            let height = img.height;            // 计算新的宽高            if (width &gt; height) &#123;              if (width &gt; MAX_WIDTH) &#123;                height *= MAX_WIDTH / width;                width = MAX_WIDTH;              &#125;            &#125; else &#123;              if (height &gt; MAX_HEIGHT) &#123;                width *= MAX_HEIGHT / height;                height = MAX_HEIGHT;              &#125;            &#125;            canvas.width = width;            canvas.height = height;            ctx.drawImage(img, 0, 0, width, height);            // 压缩为 10KB            canvas.toBlob((blob) =&gt; &#123;              if (blob.size &gt; 10 * 1024) &#123; // 10KB                reject(new Error(&#x27;Compressed file exceeds 10KB.&#x27;));              &#125; else &#123;                resolve(blob);                this.imageSrc = URL.createObjectURL(blob); // 显示预览              &#125;            &#125;, &#x27;image/jpeg&#x27;, 0.7); // 设定压缩质量          &#125;;        &#125;;        reader.readAsDataURL(file);      &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\n在这个方法中，我们首先读取文件并创建一个图像对象。在图像加载完成后，我们创建一个 canvas，设置其大小，并将图像绘制到画布上。接下来，我们使用 canvas.toBlob 方法将画布内容转换为 Blob 对象，并检查其大小是否小于 10KB。如果压缩成功，我们将 Blob 对象转换为 URL 以供预览。\n预览与用户反馈在处理完文件上传和压缩后，我们可以通过绑定 imageSrc 来显示上传后的图片预览。这样用户就可以实时查看他们上传的文件。\n1&lt;img v-if=&quot;imageSrc&quot; :src=&quot;imageSrc&quot; alt=&quot;Preview&quot; /&gt;\n\n总结通过以上步骤，我们成功创建了一个简单的文件上传组件，能够有效地限制上传文件的大小为 10KB。这种处理方式不仅能保证上传的文件符合大小要求，同时也能在一定程度上保证上传的速度和用户体验。\n如果你需要支持其他类型的文件或者扩展更多功能，可以根据实际需求对代码进行相应的修改。这种方法也可以作为其他文件处理功能的基础，帮助你在 Vue 应用中实现更复杂的文件上传逻辑。\n","slug":"在 Vue 中实现文件上传并限制文件大小为 10KB","date":"2024-11-01T06:02:00.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"权栈"},{"id":"322d11b057e8d3400060738444344655","title":"Vue3源码——render函数","content":"在了解vue render函数之前, 需要先了解下Vue的整体流程\n应该可以理解一个Vue组件是如何运行起来的.\n\n模板通过编译生成AST树\nAST树生成Vue的render渲染函数\nrender渲染函数结合数据生成vNode(Virtual DOM Node)树\nDiff和Patch后生新的UI界面(真实DOM渲染)\n\n我们需要了解以下几个概念:\n\n模板, Vue模板是纯HTML, 基于Vue的模板语法, 可以比较方便的处理数据和UI界面的关系\nAST, 即Abstract Syntax Tree的简称, Vue将HTML模板解析为AST,并对AST进行一些优化的标记处理, 提取最大的静态树,以使Virtual DOM直接跳过后面的Diff\nrender渲染函数, render渲染函数是用来生成Virtual DOM的. Vue推荐使用模板来构建我们的应用程序, 在底层实现中Vue最终还是会将模板编译成渲染函数. 因此, 若我们想要得到更好的控制, 可以直接写渲染函数.(重点)\nVirtual DOM, 虚拟DOM\nWatcher, 每个Vue组件都有一个对应的watcher, 它会在组件render时收集组件所依赖的数据, 并在依赖有更新时, 触发组件重新渲染, Vue会自动优化并更新需要更新DOM\n\n.vue单文件的实现12345678910111213141516171819202122232425262728293031&lt;template&gt;    &lt;h1 v-if=&quot;level === 1&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h1&gt;    &lt;h2 v-else-if=&quot;level === 2&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h2&gt;    &lt;h3 v-else-if=&quot;level === 3&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h3&gt;    &lt;h4 v-else-if=&quot;level === 4&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h4&gt;    &lt;h5 v-else-if=&quot;level === 5&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h5&gt;    &lt;h6 v-else-if=&quot;level === 6&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h6&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;anchored-heading&#x27;,  props: &#123;        level: &#123;            type: Number,            required: true        &#125;    &#125;&#125;&lt;/script&gt;\n\nrender函数的实现123456789101112131415Vue.component(&#x27;anchored-heading&#x27;, &#123;    render: function (createElement) &#123;        return createElement(            &#x27;h&#x27; + this.level,   // tag name 标签名称            this.$slots.default // 子组件中的阵列        )    &#125;,    props: &#123;        level: &#123;            type: Number,            required: true        &#125;    &#125;&#125;)\n\ncreateElement解析过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const SIMPLE_NORMALIZE = 1const ALWAYS_NORMALIZE = 2function createElement (context, tag, data, children, normalizationType, alwaysNormalize) &#123;    // 兼容不传data的情况    if (Array.isArray(data) || isPrimitive(data)) &#123;        normalizationType = children        children = data        data = undefined    &#125;    // 如果alwaysNormalize是true    // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值    if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE        // 调用_createElement创建虚拟节点        return _createElement(context, tag, data, children, normalizationType)    &#125;    function _createElement (context, tag, data, children, normalizationType) &#123;        /**        * 如果存在data.__ob__，说明data是被Observer观察的数据        * 不能用作虚拟节点的data        * 需要抛出警告，并返回一个空节点        *         * 被监控的data不能被用作vnode渲染的数据的原因是：        * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作        */        if (data &amp;&amp; data.__ob__) &#123;            process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(            `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\\n` +            &#x27;Always create fresh vnode data objects in each render!&#x27;,            context            )            return createEmptyVNode()        &#125;        // 当组件的is属性被设置为一个falsy的值        // Vue将不会知道要把这个组件渲染成什么        // 所以渲染一个空节点        if (!tag) &#123;            return createEmptyVNode()        &#125;        // 作用域插槽        if (Array.isArray(children) &amp;&amp; typeof children[0] === &#x27;function&#x27;) &#123;            data = data || &#123;&#125;            data.scopedSlots = &#123; default: children[0] &#125;            children.length = 0        &#125;        // 根据normalizationType的值，选择不同的处理方法        if (normalizationType === ALWAYS_NORMALIZE) &#123;            children = normalizeChildren(children)        &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123;            children = simpleNormalizeChildren(children)        &#125;        let vnode, ns        // 如果标签名是字符串类型        if (typeof tag === &#x27;string&#x27;) &#123;            let Ctor            // 获取标签名的命名空间            ns = config.getTagNamespace(tag)            // 判断是否为保留标签            if (config.isReservedTag(tag)) &#123;                // 如果是保留标签,就创建一个这样的vnode                vnode = new VNode(                    config.parsePlatformTagName(tag), data, children,                    undefined, undefined, context                )                // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义            &#125; else if ((Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123;                // 如果找到了这个标签的定义，就以此创建虚拟组件节点                vnode = createComponent(Ctor, data, context, children, tag)            &#125; else &#123;                // 兜底方案，正常创建一个vnode                vnode = new VNode(                    tag, data, children,                    undefined, undefined, context                )            &#125;        // 当tag不是字符串的时候，我们认为tag是组件的构造类        // 所以直接创建        &#125; else &#123;            vnode = createComponent(tag, data, context, children)        &#125;        // 如果有vnode        if (vnode) &#123;            // 如果有namespace，就应用下namespace，然后返回vnode            if (ns) applyNS(vnode, ns)            return vnode        // 否则，返回一个空节点        &#125; else &#123;            return createEmptyVNode()        &#125;    &#125;&#125;\n\n","slug":"Vue3源码——render函数","date":"2024-10-18T07:25:50.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"c86a81eebdde1918fe7712218383ec84","title":"Vue3源码——h函数","content":"Vue和React这类框架比起远古时期的jQuery，最大的改变就是采用了MVVM架构。\n而MVVM架构的核心，则是虚拟DOM。\n基本概念虚拟DOM说到虚拟DOM，先得说起真实DOM。真实的DOM就是一颗HTML树，里面包含了节点、属性（class、id、style等）、子节点信息。\n例如这样的DOM节点\n1&lt;div id=&quot;app&quot; class=&quot;test&quot;&gt;hello world&lt;/div&gt;\n\n虚拟的DOM也要包括和真实DOM一样的信息。区别在于，它用JS对象来表示\n例如刚才的DOM节点，用JS可以这样表示\n12345678const vnode = &#123;    type: &quot;div&quot;,    props: &#123;        id: &quot;app&quot;,        class: &quot;test&quot;    &#125;,    children: &quot;hello world&quot;&#125;\n\n可以看出，这个vnode对象，用了type、props和children分别表示了这个真实DOM节点的类型（div）、属性（id为app，class为test）以及子节点（字符串hello world）。看着这样格式的JS对象，我们也可以很容易地推理得到一个真实的DOM节点。我们把这样的一个对象称之为虚拟DOM。\nh函数在Vue源码中，虚拟DOM是由h函数生成的。生成时同样可以传入节点类型、属性以及子节点信息。\n1h(&quot;div&quot;, &#123; id: &quot;app&quot;, class: &quot;test&quot; &#125;, &quot;hello world&quot;)\n\n尝试打印这个h函数生成的vnode，内部信息比较丰富，用注释标注了一些核心的属性\n1234567891011121314151617181920212223242526272829303132&#123;        // 是否是VNode对象        &quot;__v_isVNode&quot;: true,        &quot;__v_skip&quot;: true,        // 节点类型        &quot;type&quot;: &quot;div&quot;,        // 节点属性        &quot;props&quot;: &#123; &quot;class&quot;: &quot;test&quot;, &quot;id&quot;: &quot;app&quot; &#125;,        &quot;key&quot;: null,        &quot;ref&quot;: null,        &quot;scopeId&quot;: null,        &quot;slotScopeIds&quot;: null,        // 子节点        &quot;children&quot;: &quot;hello world&quot;,        &quot;component&quot;: null,        &quot;suspense&quot;: null,        &quot;ssContent&quot;: null,        &quot;ssFallback&quot;: null,        &quot;dirs&quot;: null,        &quot;transition&quot;: null,        &quot;el&quot;: null,        &quot;anchor&quot;: null,        &quot;target&quot;: null,        &quot;targetAnchor&quot;: null,        &quot;staticCount&quot;: 0,        &quot;shapeFlag&quot;: 9,        &quot;patchFlag&quot;: 0,        &quot;dynamicProps&quot;: null,        &quot;dynamicChildren&quot;: null,        &quot;appContext&quot;: null&#125;\n\nh函数框架基本框架对于h函数，我们知道应该包括三个参数\n\n节点类型type\n属性props（可选）\n子节点children（可选）\n\n考虑到属性和子节点都是可选参数，因此要针对入参数量和类型做一些判断，大概的规则如下\n12345678910111213141516171819202122232425export function h(type: any, propsOrChildren?: any, children?: any): VNode &#123;  const l = arguments.length;  // 两个参数，不知道是props没传还是children没传  if (l == 2) &#123;    if (isObject(propsOrChildren) &amp;&amp; !isArray(propsOrChildren)) &#123;      if (isVNode(propsOrChildren)) &#123;        return createVNode(type, null, [propsOrChildren]);      &#125;      return createVNode(type, propsOrChildren, []);    &#125; else &#123;      return createVNode(type, null, propsOrChildren);    &#125;  &#125; else &#123;    // 三个及以上的参数，肯定是props和children都有    if (l &gt; 3) &#123;      children = Array.prototype.slice.call(arguments, 2);    &#125; else if (l === 3 &amp;&amp; isVNode(children)) &#123;      children = [children];    &#125;    return createVNode(type, propsOrChildren, children);  &#125;&#125;\n\n至于是否为vnode的判断，直接根据__v_isVNode属性就可得知\n123export function isVNode(value: any): value is VNode &#123;  return value ? value.__v_isVNode === true : false;&#125;\n\n整体框架出来了，接下来vnode的生成，主要就是createVNode这个方法了\nvnode的类型关于DOM节点，我们大概可以分成这样一些类别\n\n标准节点：div、h1等常规标签\n注释节点\nFragment节点\n组件\n……\n\n那么，相对的，vnode也会区分一些节点类型。\n查看Vue源码可以得知，里面包含了文本节点Text、片段节点Fragment、DOM节点Element、组件节点Component、注释节点Comment等等。\n此外，对于children来说，可能是一个，也可能是数组，甚至是对象、函数等等多种不同类型。\n源码中，为了区分不同的节点，使用了shapeFlag，而且这个值还用二进制位进行计算。\n123456789101112131415161718192021222324252627282930export const enum ShapeFlags &#123;  /**   * type = Element   */  ELEMENT = 1,  /**   * 函数组件   */  FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1,  /**   * 有状态（响应数据）组件   */  STATEFUL_COMPONENT = 1 &lt;&lt; 2,  /**   * children = Text   */  TEXT_CHILDREN = 1 &lt;&lt; 3,  /**   * children = Array   */  ARRAY_CHILDREN = 1 &lt;&lt; 4,  /**   * children = slot   */  SLOTS_CHILDREN = 1 &lt;&lt; 5,  /**   * 组件：有状态（响应数据）组件 | 函数组件   */  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT,&#125;\n\nh函数实现element节点+文本childrenh函数最简单的用法是创建一个有tag名称的节点，子节点是文本。\n1const vnode = h(&quot;div&quot;, &quot;hello world&quot;);\n\n为了实现VNode的构建，需要先构建createVNode方法，接收type、props、children这三个参数。\n123456789101112131415export interface VNode &#123;  __v_isVNode: true  type: any  props: any  children: any  shapeFlag: number&#125;export function createVNode(type, props, children): VNode &#123;  // 这里先处理文本类型，其他的shapeFlag先不处理  const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0;    return createBaseVNode(type, props, children, shapeFlag);&#125;\n\n生成了shapeFlag后，要先创建VNode的一些基本属性，源码中用的就是createBaseVNode方法，并且在这之后使用normalizeChildren标准化children的类型（即使用位或运算得到一个shapeFlag值）\n123456789101112131415161718192021222324252627282930313233// 创建基础vnodefunction createBaseVNode(type, props, children, shapeFlag) &#123;  const vnode = &#123;    __v_isVNode: true,    type,    props,    shapeFlag,  &#125; as VNode;  normalizeChildren(vnode, children);  return vnode;&#125;function normalizeChildren(vnode: VNode, children: unknown) &#123;  let type = 0;  if (children === null) &#123;    children = null;  &#125; else if (isArray(children)) &#123;    // TODO: 数组类型children处理  &#125; else if (typeof children === &quot;object&quot;) &#123;    // TODO: 对象类型的children处理  &#125; else if (isFunction(children)) &#123;    // TODO: 函数类型的children处理  &#125; else &#123;    children = String(children);    type = ShapeFlags.TEXT_CHILDREN;  &#125;  vnode.children = children;  vnode.shapeFlag |= type;&#125;\n\n此时我们可以通过h函数拿到tag为string（例如div、p等），且children内容是text的vnode值了，和源码的核心内容是一致的\n123const vnode = h(&quot;div&quot;, &quot;hello world&quot;);console.log(vnode); // shapeFlag是9，children是hello world\n\nelement节点+数组children相比于上一个节点类型，这个的区别就是children不再是一个节点，而是多个\n1const vnode = h(&quot;div&quot;, [h(&quot;p&quot;, &quot;p1&quot;), h(&quot;p&quot;, &quot;p2&quot;), h(&quot;p&quot;, &quot;p3&quot;)]);\n\n其中每一个节点的解析就是刚才element+text这种组合，而且这几个节点会先被处理成VNode，唯一的区别是整体div这个节点\n查看源码可以知道，我们只需要在最后生成div的VNode的时候提供一个type数值就行\n123456789function normalizeChildren(vnode: VNode, children: unknown) &#123;  ......  else if (isArray(children)) &#123;    type = ShapeFlags.ARRAY_CHILDREN;  &#125;    ......&#125;\n\n这时候这个VNode的打印结果就和源码核心一致了\n123const vnode = h(&quot;div&quot;, [h(&quot;p&quot;, &quot;p1&quot;), h(&quot;p&quot;, &quot;p2&quot;), h(&quot;p&quot;, &quot;p3&quot;)]);console.log(vnode); // shapeFlag是17，children也是vnode节点，shapeFlag都是9\n\n从这里不难发现，VNode中一个很关键的属性是shapeFlag，正如名字一样，它描述了虚拟DOM节点的形状，而这个形状包括了父节点类型和子节点类型&#x2F;形状，其中：\n\ncreateBaseVNode：提供了父节点的类型\nnormalizeChildren：提供了子节点的类型和形状\n\n组件Component首先要明确一个问题：在Vue中，组件的本质是对象&#x2F;函数\n所以实际上在Vue中写的组件，如果需要渲染的话，要用对象包裹，其中包含一个render方法\n12345678910const component = &#123;  render() &#123;    const vnode1 = h(&quot;div&quot;, &quot;this is component&quot;);    return vnode1;  &#125;,&#125;;const vnode2 = h(component);render(vnode2, document.querySelector(&#x27;#app&#x27;));\n\n按照之前的h函数实现和理解，其实我们可以在component的render中直接返回一个VNode对象，render方法直接给一个VNode对象，也能达到一样的效果，主要的注意点就是shapeFlag值要保持和源码一致\n12345678910111213141516const component = &#123;  render() &#123;    return &#123;      v__is_vnode: true,      type: &quot;div&quot;,      children: &quot;this is component&quot;,      shapeFlag: 9    &#125;  &#125;&#125;render(&#123;  v__is_vnode: true,  type: component,  shapeFlag: 4&#125;, document.querySelector(&#x27;#app&#x27;));\n\n所以只需要注意处理一下type和shapeFlag值，就可以完成组件component的h函数了，只要在createVNode中修改一行即可\n12345678910function createVNode(type, props, children): VNode &#123;  ......  const shapeFlag = isString(type)    ? ShapeFlags.ELEMENT    : isObject(type)    ? ShapeFlags.STATEFUL_COMPONENT    : 0;  ......&#125;\n\n按照之前的代码，最后生成的VNode里的children会变成”undefined”，其实是normalizeChildren里面的判断条件过于严苛了，把===改成==即可\n1234567function normalizeChildren(vnode: VNode, children: unknown) &#123;  ......  if (children == null) &#123;    children = null;  &#125;  ......&#125;\n\n其他一些简单节点这里的简单节点包括：\n\n纯文本Text\n注释Comment\n片段Fragment\n\n查看源码可以发现，用h函数构建的这些节点的type都是Symbol类型，shapeFlag都是8\n12345const vnodeText = h(Text, &quot;this is text&quot;);const vnodeComment = h(Comment, &quot;this is comment&quot;);const vnodeFragment = h(Fragment, &quot;this is fragment&quot;);\n\n相比于之前的代码，我们只需要考虑type的问题，这里直接创建几个常量处理即可\n123export const Fragment = Symbol(&quot;Fragment&quot;);export const Text = Symbol(&quot;Text&quot;);export const Comment = Symbol(&quot;Comment&quot;);\n\n处理完之后，h函数对这些简单节点的输出就和源码核心保持一致了\nclass和style的增强处理Vue中对class和style，支持使用数组&#x2F;对象，动态绑定值\n12345const vnode = h(&#x27;div&#x27;, &#123;  class: &#123;    &#x27;red&#x27;: true  &#125;&#125;, &#x27;improve class&#x27;);\n\n按照上面的代码，可以拿到一个带有class为red的div\n阅读源码得知，这个增强处理需要添加一个normalizeClass方法，方法本质上也是对class对象做一个遍历，针对string&#x2F;array&#x2F;object做不同的处理方式，最后拼接成string\n123456789101112131415161718192021222324252627282930313233function normalizeClass(value: unknown): string &#123;  let res = &quot;&quot;;  if (isString(value)) &#123;    res = value;  &#125; else if (isArray(value)) &#123;    for (let i = 0; i &lt; value.length; i++) &#123;      const normalized = normalizeClass(value[i]);      if (normalized) &#123;        res += normalized + &quot; &quot;;      &#125;    &#125;  &#125; else if (isObject(value)) &#123;    for (const name in value as object) &#123;      if ((value as object)[name]) &#123;        res += name + &quot; &quot;;      &#125;    &#125;  &#125;  return res.trim();&#125;function createVNode(type, props, children): VNode &#123;  if (props) &#123;    let &#123; class: klass, style &#125; = props;    if (klass &amp;&amp; !isString(klass)) &#123;      props.class = normalizeClass(klass);    &#125;  &#125;  ......&#125;\n\nstyle的处理逻辑上和class一致\n","slug":"Vue3源码——h函数","date":"2024-10-12T06:57:10.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"a4c1e6f4a7d260a2971f3f08fe46eea6","title":"Vue3.5 useId","content":"useId的作用他的作用也是生成唯一ID，同一个Vue应用里面每次调用useId生成的ID都不同。\n使用方法也很简单，代码如下：\n123456789101112&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useId &#125; from &#x27;vue&#x27;const id0 = useId();console.log(id0); // v-0const id1 = useId();console.log(id1); // v-1const id2 = useId();console.log(id2); // v-2&lt;/script&gt;\n\nuseId是如何实现的来看看useId的源码，非常简单！！简化后的代码如下：\n12345678function useId(): string &#123;  const i = getCurrentInstance()  if (i) &#123;    return (i.appContext.config.idPrefix || &#x27;v&#x27;) + &#x27;-&#x27; + i.ids[0] + i.ids[1]++  &#125;  return &#x27;&#x27;&#125;\n\n总结生成的ID分为三部分：\n\n第一部分为前缀：app.config.idPrefix，如果没有配置，那么就是字符串v。\n\n第二部分字符串：-。\n\n第三部分的值为一个自增的数字，存在vue实例上面的ids属性，所有的vue实例上面的ids属性都是指向同一个数组。这也就是为什么说useId可以在Vue应用内生成唯一的ID，而不是在Vue组件内生成唯一的ID。\n\n\n","slug":"Vue3.5 useId","date":"2024-09-27T07:14:20.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"56ce95bec0e493691d1f055dfbf1898e","title":"前端优化首次加载速度","content":"compression-webpack-plugincompression-webpack-plugin 是一个 Webpack 插件，用于压缩生成的静态文件，通常是使用 Gzip 或 Brotli 压缩格式。这有助于减小文件大小，从而提高网页加载速度和性能。\nclean-webpack-pluginclean-webpack-plugin 是一个 Webpack 插件，用于在每次构建前自动清理输出目录（如 dist 文件夹），以确保新构建的文件是最新的，避免遗留旧文件。\nterser-webpack-pluginterser-webpack-plugin 是一个 Webpack 插件，用于压缩和混淆 JavaScript 代码，通常在生产环境中使用。它基于 Terser 工具，能够有效地减少 JavaScript 文件的体积，从而提高网页加载速度。\nhtml-webpack-pluginhtml-webpack-plugin 是一个 Webpack 插件，用于简化生成 HTML 文件的过程，通常用于将打包的 JavaScript 和 CSS 文件自动注入到 HTML 模板中。\n@vue&#x2F;preload-webpack-plugin@vue&#x2F;preload-webpack-plugin 是一个 Webpack 插件，主要用于优化 Vue 应用的资源加载性能。它可以自动添加  标签到生成的 HTML 文件中，以便浏览器预加载关键资源（如 JavaScript 和 CSS 文件）。\nvue.config 文件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172const path = require(&quot;path&quot;);const px2rem = require(&quot;postcss-px2rem&quot;);const postcss = px2rem(&#123;  remUnit: 37.5, // 基准大小 baseSize，需要和rem.js中相同&#125;);let productionGzipExtensions = /\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$/i;const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;); // 用于在每次构建前清理 /dist 文件夹const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); // 用于压缩 JavaScript 代码const &#123; BundleAnalyzerPlugin &#125; = require(&quot;webpack-bundle-analyzer&quot;); //const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const PreloadPlugin = require(&quot;@vue/preload-webpack-plugin&quot;);require(&quot;events&quot;).EventEmitter.defaultMaxListeners = 0;module.exports = &#123;  // 路径前缀  publicPath: process.env.VUE_APP_PUBLICPATH,  assetsDir: &quot;static&quot;,  // 是否启用 eslint-loader 在保存时检查代码  lintOnSave: true,  // 是否生成 source map 文件，生产环境可以关闭以提升打包速度  productionSourceMap: process.env.NODE_ENV == &quot;development&quot;,  // 扩展 webpack-chain 配置，进一步优化 Webpack 配置  chainWebpack: (config) =&gt; &#123;    // 忽略的打包文件    config.externals(&#123;      vue: &quot;Vue&quot;,      &quot;vue-router&quot;: &quot;VueRouter&quot;,      vuex: &quot;Vuex&quot;,      axios: &quot;axios&quot;,      &quot;element-ui&quot;: &quot;ELEMENT&quot;,    &#125;);    // 配置入口文件    const entry = config.entry(&quot;app&quot;);    entry.add(&quot;babel-polyfill&quot;).end();    entry.add(&quot;classlist-polyfill&quot;).end();    entry.add(&quot;@/mock&quot;).end();    // // 配置预加载和预取，优化加载性能    // config.plugin(&quot;preload&quot;).tap((options) =&gt; &#123;    //   options[0].fileBlacklist.push(/\\.map$/, /hot-update\\.js$/);    //   return options;    // &#125;);    // 移除 prefetch 插件，避免加载不必要的资源    // config.plugins.delete(&quot;prefetch&quot;);  &#125;,  // 配置 Webpack  configureWebpack: (config) =&gt; &#123;    const plugins = [      new CleanWebpackPlugin(),      new HtmlWebpackPlugin(&#123;        filename: &quot;index.html&quot;,        template: &quot;public/index.html&quot;,        inject: true,        templateParameters: &#123;          BASE_URL: &quot;/&quot;, // 传递 BASE_URL 到模板        &#125;,      &#125;),      new PreloadPlugin(&#123;        rel: &quot;preload&quot;,        include: &quot;initial&quot;,        fileBlacklist: [/\\.map$/, /hot-update\\.js$/, /vendor\\..*\\.js$/],        // 根据需要进行更多配置      &#125;),    ];    if (      process.env.NODE_ENV === &quot;production&quot; ||      process.env.NODE_ENV === &quot;test&quot;    ) &#123;      plugins.push(        new CompressionPlugin(&#123;          filename: &quot;[path][base].gz&quot;,          algorithm: &quot;gzip&quot;,          test: productionGzipExtensions,          threshold: 10240,          minRatio: 0.8,          deleteOriginalAssets: false,          // exclude: /(cdn|util)\\/.*\\.(js|css|json|txt|html|ico|svg)$/i,        &#125;),        new BundleAnalyzerPlugin(&#123;          analyzerMode: &quot;static&quot;,          reportFilename: &quot;bundle-report.html&quot;,          openAnalyzer: true,        &#125;)      );      config.optimization = &#123;        minimize: true,        minimizer: [          new TerserPlugin(&#123;            terserOptions: &#123;              compress: &#123;                drop_console: true,                drop_debugger: true,              &#125;,              output: &#123;                comments: false,              &#125;,            &#125;,            parallel: true,          &#125;),        ],        splitChunks: &#123;          // Uncomment this block if needed          chunks: &quot;all&quot;,          maxInitialRequests: 5,          minSize: 30000,          maxSize: 250000,          cacheGroups: &#123;            vendor: &#123;              test: /[\\\\/]node_modules[\\\\/]/,              name(module) &#123;                const packageName = module.context.match(                  /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/                )[1];                return `npm.$&#123;packageName.replace(&quot;@&quot;, &quot;&quot;)&#125;`;              &#125;,              priority: -10,            &#125;,            common: &#123;              name: &quot;common&quot;,              minChunks: 2,              priority: -20,              reuseExistingChunk: true,              chunks: &quot;all&quot;,            &#125;,          &#125;,        &#125;,      &#125;;    &#125; else if (process.env.NODE_ENV === &quot;development&quot;) &#123;      config.devtool = &quot;source-map&quot;;    &#125;    config.plugins.push(...plugins);  &#125;,  css: &#123;    extract: &#123; ignoreOrder: true &#125;,    loaderOptions: &#123;      postcss: &#123;        plugins: [postcss],      &#125;,    &#125;,  &#125;,  transpileDependencies: [&quot;ol&quot;],  // 开发模式反向代理配置，生产模式请使用Nginx部署并配置反向代理  devServer: &#123;    port: 1888,    proxy: &#123;      &quot;/api&quot;: &#123;        // 本地服务接口地址        target: process.env.VUE_APP_BASE_API_COMMON_URL,        // 远程演示服务地址, 可用于直接启动项目        // target: &#x27;https://saber.bladex.vip/api&#x27;,        ws: true,        pathRewrite: &#123;          &quot;^/api&quot;: &quot;/&quot;,        &#125;,      &#125;,    &#125;,  &#125;,  // 通过环境变量控制是否启用性能提示  //  performance: &#123;  //   hints: (process.env.NODE_ENV === &#x27;production&#x27; || process.env.NODE_ENV === &#x27;test&#x27;) ? &#x27;warning&#x27; : false  // &#125;&#125;;\n\n修改测试环境配置NODE_ENV 是一个环境变量，用于指示 Node.js 应用程序的运行环境。它通常有三个主要值： development 、 production 和 test 。\n只有 production 生成环境才会压缩文件 如果是 NODE_ENV&#x3D;test 改成 NODE_ENV&#x3D;production\n\n修改动态路由懒加载方式\n加载时机：\nrequire：同步加载，运行时决定。\nimport：异步加载，编译时确定。\n\n\n作用域：\nrequire：在模块内部，作用域较封闭。\nimport：支持命名导入和默认导入，灵活性更高。\n\n\n环境：\nrequire：主要用于 Node.js。\nimport：适用于现代浏览器和支持 ES6 的环境。\n\n\n\n\n","slug":"前端优化首次加载速度","date":"2024-09-20T07:08:20.000Z","categories_index":"Vue2","tags_index":"Vue2","author_index":"权栈"},{"id":"d5edacab67506b18e45fcb0990be9618","title":"前端大屏自适应方案","content":"易用 🚀调用仅需一行代码，即可适配设置分辨率以下的所有屏幕，无需任何其他辅助\n性能 ⚡只影响一个元素样式，计算量极小\n灵活 💥可以给项目全局自适应，也可以单独页面做自适应\n原理即在 scale 等比缩放的基础上，获取屏幕的宽度除以设计稿的宽度，获取到宽度比例值；获取屏幕的高度除以设计稿的高度，获取到高度比例值；使用 transform: scale(x, x) 动态监听来实现页面的缩放比例，从而还原 UI 图效果。这可以支持设计稿以下的各种分辨率。\n使用代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* 根据视口尺寸调整给定元素的缩放比例。 * @param &#123;HTMLElement&#125; e - 要调整的元素。 * @param &#123;number&#125; planWidth - 元素的计划宽度,默认1980px。 * @param &#123;number&#125; planHeight - 元素的计划高度,默认1080px。 */    function selfAdaption(e, planWidth = 1980, planHeight = 1080) &#123;      /**       * 获取客户端视口的当前尺寸，并根据最小计划尺寸进行调整。       * @returns &#123;&#123;width: number, height: number&#125;&#125; 客户端视口的调整后宽度和高度。       */      console.log(planWidth, planHeight);      const getClientDimensions = () =&gt; &#123;        // 获取客户端视口的当前宽度和高度        let width = document.body.clientWidth || document.documentElement.clientWidth;        let height = document.body.clientHeight || document.documentElement.clientHeight;        // 如果计划高度小于1080，则进行高度调整        if (planHeight &lt; 1080) &#123;          height -= (1080 - planHeight);        &#125;        // 如果计划宽度小于1920，则进行宽度调整        if (planWidth &lt; 1920) &#123;          width -= (1920 - planWidth);        &#125;        return &#123; width, height &#125;;      &#125;;      /**       * 根据当前视口尺寸更新元素的缩放比例。       */      const updateScale = () =&gt; &#123;        // 获取调整后的客户端尺寸        const &#123; width, height &#125; = getClientDimensions();        // 计算宽度和高度的缩放比例        const ratioWidth = width / planWidth;        const ratioHeight = height / planHeight;        // 对元素应用缩放变换        e.style.transform = `scale($&#123;ratioWidth&#125;, $&#123;ratioHeight&#125;)`;      &#125;;      // 设置元素的初始样式      e.style.cssText += `    transform-origin: 0 0 0;    display: flex;    min-width: auto;    min-height: auto;    overflow: hidden;    width: $&#123;planWidth&#125;px;    height: $&#123;planHeight&#125;px;  `;      // 初始更新缩放比例      updateScale();      // 添加事件监听器，在窗口调整大小时更新缩放比例      window.addEventListener(&#x27;resize&#x27;, updateScale);    &#125;selfAdaption（e）传递的要自适应最外层dom\n\n\n\n\n\n\n\n\n\n\n使用 transform: scale 自适应后，地图上点击事件失效，解决办法：\n12345678910resetMapSize() &#123;        let mapContent = document.getElementById(&quot;map&quot;);        mapContent.style.transform = `scale($&#123;1 / ratioWidth&#125;,$&#123;1 / ratioHeight&#125;)`      &#125;  // 用完后记得销毁监听事件 比如 vue 中  destroyed () &#123;      window.removeEventListener(&#x27;resize&#x27;,this.resetMapSize)    &#125; \n","slug":"前端大屏自适应方案","date":"2024-09-12T02:58:20.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"32c8c23c6d89385feba3d0e7e602221c","title":"Vue3.5 源码解析， useTemplateRef 实现原理","content":"useTemplateRef 的作用useTemplateRef 是用来专门获取 dom 或者 组件示例 的。\n在之前，如果我们想要获取 dom ，那么需要这么做：\n\n先为 dom 指定 ref 属性，并且给定一个 value 值\n\n在 js 中，声明 value 值的变量，并且给定初始值为 空的 ref\n12345678910&lt;script setup&gt;// 首先，您定义了一个值为undefined或空的ref// 并以您想要的方式命名生成的可用内容const divEl = ref();&lt;/script&gt;&lt;template&gt;&lt;!-- 然后使用与“ref”属性的值相同的名称,在模板中的某个地方 --&gt;&lt;div ref=&quot;divEl&quot; &gt;&lt;/div&gt;&lt;/template&gt;\n\n但是，这种方案存在一个问题，那就是：ref 通常用来声明响应式数据。当 ref 不光作为响应式声明，还被作为 dom 实例的时候，那么就难免有点让人疑惑了。\n所以在（3.5 之后） Vue 推出了一个新的 API 叫做 useTemplateRef 来解决这个问题：\n123456789101112131415&lt;template&gt; &lt;div&gt;  &lt;div ref=&quot;el&quot;&gt;程序员Sunday&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted, useTemplateRef &#125; from &#x27;vue&#x27;const elRef = useTemplateRef(&#x27;el&#x27;)onMounted(() =&gt; &#123; console.log(elRef.value) // dom 示例&#125;)&lt;/script&gt;\n\nuseTemplateRef 的实现原理1234567891011121314export function useTemplateRef(key: Keys) &#123;  const i = getCurrentInstance();  const r = shallowRef(null);  if (i) &#123;    const refs = i.refs === EMPTY_OBJ ? (i.refs = &#123;&#125;) : i.refs;    Object.defineProperty(refs, key, &#123;      enumerable: true,      get: () =&gt; r.value,      set: (val) =&gt; (r.value = val),    &#125;);  &#125;  return r;&#125;\n\n第一个 i：通过 getCurrentInstance() 获取，得到的是 上下文实例。​ 接下来，通过 i.refs 获取到所有的 ref 数据，然后为 refs 添加 Object.defineProperty 的监听，监听的属性名就是入参 key。如果以 useTemplateRef(‘el’) 为例，那么就是 “el”。\n通过监听对应 key 的 get 和 set 标记，这里 重点关注 set 标记，在这里为 r.value 进行了赋值，即：r.value &#x3D; val。这里的 val 就是 refs[key] 的值，也就是对应的 ref 组件实例。\n第二个 r：通过 shallowRef(null) 获取，作为返回值r 作为 useTemplateRef 的返回值即 最终获取的组件示例。\n","slug":"Vue3.5 源码解析， useTemplateRef 实现原理","date":"2024-09-06T06:07:04.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"c34479c7fc43ef2eede71b250f18b4aa","title":"ref和reactive原理","content":"refref 的处理上就是先将基本类型转换成对象类型，然后在里面加入一个 this._v_isRef 的布尔类型的值，来判断它是不是被 ref 处理了，然后将上面写的 track 和 trigger 函数写入 get 和 set 函数里面，如果你要处理的是一个对象，那么 vue3 就会把它改成 reactive 的处理方式。所以说，ref 可以处理基本类型和引用类型，而 reactive 处理的是引用类型，二者的区别不是很大。\nreactive\n首先我们取一个对象{a: 1}\n\n然后调用封装好的 reactive 函数 const state &#x3D; reactive({a: 1})\n\n这个时候就会进入代码片段 1.1 里面的 reactive 函数，在进入 createReactiveObject 函数\n\n然后就会对我们要代理的对象进行判断，如果是对象的话就继续下去\n\n在判断我们是不是已经代理过这个对象（就是我们预先空出一个位置，将已经代理过的对象全部存储下来），代理过就返回代理后的值，没有的话就创建一个新的代理\n\n再然后绑定上 proxy 函数里面的 get 和 set 回调函数（可以看到代码 1.2）\n\n\n","slug":"ref和reactive原理","date":"2024-08-27T08:30:20.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"2e839452302506867eaaf60fd116d0d6","title":"vue3 Api","content":"defineProps()和 defineEmits()\nv-model:childValueModel 修改了值 本来应该是 modeValue\ndefineEmites() 使用要添加 update:\n1&lt;defineModelChild v-model;childValueModel=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;\n\n​\n123456789&lt;template&gt;&lt;div&gt;&#123;&#123; childValueModel &#125;&#125;&lt;/div&gt;&lt;button @click=&quot;myEmits(&#x27;update:childValueModel&#x27;, childValueModel + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const myProps = defineProps([&#x27;childValueModel&#x27;]);const myEmits= defineEmits([&#x27;update:childValueModel&#x27;]);&lt;/script&gt;\n\n父组件\n12345678910111213&lt;script setup&gt;import HelloWorld from &#x27;./components/defineProps-----defineEmits .vue&#x27;//父组件function count(value) &#123;  console.log(value);&#125;&lt;/script&gt;&lt;template&gt;  &lt;HelloWorld a=&quot;qwdqwd&quot;    @count=&#x27;count&#x27; /&gt;&lt;/template&gt;\n\n子组件\n1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;//子组件let count = ref(0)let emit = defineEmits([&quot;count&quot;])const props = defineProps((&#123;  a: String&#125;))function increment() &#123;  count.value++  emit(&quot;count&quot;, count.value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125; &#123;&#123;props.a&#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\ndefineModel() 3.4+版本\ndefineModel 其实也是一个语法糖，是对 v-model 再包装的语法糖\ndefineModel 帮你获取到了 prop 中的 modelValue ，且当 值发生变化时，会自动帮你调用 update:modelValue\n123456const myProps = defineProps([&quot;modelValue&quot;]);const myEmits = defineEmits([&quot;update:modelValue&quot;]);// 说白了，这里的 modelValue 等价于 props.modelValue + emit(&#x27;update:modelValue&#x27;)// defineModel 帮你 封装了 modelValue 和 update:modelValueconst modelValue = defineModel();\n\n父组件\n12345678910&lt;template&gt;  &lt;defineModelChild v-model=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import defineModelChild from &#x27;./components/defineModelChild.vue&#x27;;const childValue = ref(0);&lt;/script&gt;\n\nv-model 子组件\n1234567891011&lt;template&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;myEmits(&#x27;update:modelValue&#x27;, modelValue + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;defineProps([&#x27;modelValue&#x27;]);const myEmits = defineEmits([&#x27;update:modelValue&#x27;]);&lt;/script&gt;\n\ndefineModel() 子组件\n12345678&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;modelValue++&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const modelValue = defineModel();&lt;/script&gt;\n\ndefineExpose 子传父\n（用在子组件，暴露想传递的值或方法，父组件通过 ref 属性获取子组件暴露的）\n使用 script setup 的组件是默认关闭的——即通过模板引用或者 $parent 链获取到的组件的公开实例，不会暴露任何在 script setup 中声明的绑定。\n那么，通过 defineExpose 编译器宏来显式指定在\n然后，父组件通过 ref 属性访问子组件\n父组件：\n123456789101112131415161718&lt;Index ref=&quot;childeRef&quot;&gt;&lt;/Index&gt;&lt;script setup&gt;    import Index from &quot;./index.vue&quot;;    const childeRef = ref();    function test() &#123;        console.log(childeRef.value.msg) // Hello World    &#125;    onMounted(() =&gt; &#123;      let flag:boolean = true;      let value:number= 5;      childeRef.value.childFn(flag,value) // 调用子组件函数, 输出 6    &#125;)&lt;/script&gt;\n\n子组件：\n1234567891011121314151617&lt;script setup&gt;    import &#123;ref&#125; from &quot;vue&quot;;    function childFn(type：boolean, data：number) &#123;        console.log(&#x27;我是子组件&#x27;);        if(data)&#123;           let value = data + 1;           return value;        &#125;    &#125;    const msg = &#x27;Hello World&#x27;;    defineExpose(&#123; //暴露想要传递的值或方法        msg,        childFn,    &#125;);&lt;/script&gt;\n\ndefineOptions 3.3+\n123456789&lt;script setup&gt;import &#123; defineOptions &#125; from &#x27;vue&#x27;defineOptions(&#123;name: &#x27;Foo&#x27;,//组件重命名 inheritAttrs: false,//...更多自定义属性&#125;)&lt;/script&gt;\n\ncomputed 计算属性\n1234567891011121314151617181920212223&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123; publishedBooksMessage &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\ncomputed 传参\n12345678910111213141516171819202122232425262728&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  name: &#x27;John Doe&#x27;,  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return function (value) &#123;    console.log(value)    return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Has published books:&lt;/p&gt;    &#123;&#123; publishedBooksMessage(12) &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatch 监听\n默认开启深度监听\n123456789101112131415161718192021222324252627282930&lt;script setup &gt;import &#123; ref, watch &#125; from &quot;vue&quot;const count = ref(0)const btnClick = () =&gt; &#123;  count.value++;&#125;// ✅ 方法一，传递响应对象watch(count, (newValue, oldValue) =&gt; &#123;  console.log(newValue, oldValue)&#125;)// ❌ 方法二：传递响应对象下的属性watch(user.name, (value) =&gt; &#123;    console.log(value) // 监听失败，没输出&#125;)// ✅ 方法三：传递函数，函数返回响应对象属性watch(() =&gt; user.name, (value) =&gt; &#123;    console.log(value); // 监听成功，输出 jake&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123; count &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatchEffect 的使用\nwatchEffect 也是一个帧听器，是一个副作用函数。 它会监听引用数据类型的所有属性，不需要具体到某个属性，一旦运行就会立即监听，组件卸载的时候会停止监听。\n123456789101112131415161718192021222324&lt;script setup &gt;import &#123; reactive, ref, watch, watchEffect &#125; from &quot;vue&quot;const count = reactive(&#123; name: &#x27;112&#x27;, data: [&quot;你好&quot;] &#125;)const btnClick = () =&gt; &#123;  count.data[0] = &#x27;被改了&#x27;&#125;watchEffect(() =&gt; &#123;  console.log(count.data[0]);&#125;) watch([count,obj],() =&gt; &#123;      console.log(&#x27;监听的多个数据改变了&#x27;)    &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123;count.data[0]&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nstopWatchEffect 停止监听\n1234567const stop = watchEffect(() =&gt; &#123;  console.log(&quot;name:&quot;, obj.name);&#125;);const stopWatchEffect = () =&gt; &#123;  console.log(&quot;停止监听&quot;);  stop();&#125;;\n\nonInvalidate 函数 解决执行顺序乱的问题\n","slug":"vue3 Api","date":"2024-06-13T08:39:58.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"}]