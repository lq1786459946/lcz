[{"id":"da2d755c98b04089d7596f9ea22513af","title":"瀑布流","content":"什么是瀑布流瀑布流布局，作为一种现代网页设计中的创新布局方式，以其独特的视觉风格和流畅的用户体验在众多网站设计中脱颖而出。这种布局模式被形象地称为“瀑布流”\n瀑布流布局的核心特征多列等宽不等高：瀑布流布局以多列的形式展现内容，每列宽度保持一致，而高度则根据所容纳内容的大小动态调整，形成错落有致的视觉效果。\n动态加载与无限滚动：用户在浏览过程中，随着滚动页面，新的内容块会自动加载，实现了“无尽”的内容流，减少了分页操作，提升了浏览连贯性。\n视觉吸引力：尤其擅长展示图片或视觉元素丰富的媒体内容，为用户提供了沉浸式的浏览体验，增加了页面的观赏性和互动性。\n设计瀑布流布局\n先获取屏幕的大小\n获取图片的宽度\n确定第一行能放几张图（n张）\n操作第 n+1 张 摆放它的位置，将其放在高度最小的那一列\n获取每一列的高度\n放入图片后，更新这一列的高度\n\nHTML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;   &lt;style&gt;    *&#123;      margin: 0;      padding: 0;    &#125;    #container&#123;      position: relative;    &#125;    .box&#123;      float: left;      padding: 5px;    &#125;    .box-img&#123;      width: 150px;      padding: 5px;      border: 1px solid #aaa;    &#125;    img&#123;      width: 100%;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;box-img&quot;&gt;        &lt;img src=&quot;./img/1.webp&quot; alt=&quot;&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;    ···    ···    ···    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;box-img&quot;&gt;        &lt;img src=&quot;./img/9.webp&quot; alt=&quot;&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;box-img&quot;&gt;        &lt;img src=&quot;./img/10.webp&quot; alt=&quot;&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\njs1234567891011121314151617181920212223242526272829303132333435window.onload = function() &#123;    imgLocation(&#x27;container&#x27;, &#x27;box&#x27;)        function imgLocation(parent, child) &#123;      var cParent = document.getElementById(parent)      var cChild = cParent.getElementsByClassName(child)      var screenWidth = window.innerWidth      var imgWidth = cChild[0].offsetWidth      var num = Math.floor(screenWidth / imgWidth)      cParent.style.width = `$&#123;imgWidth * num&#125;px`        // 操作第 num+1 张      var boxHeightArr = []      for (var i = 0; i &lt; cChild.length; i++) &#123;        if (i &lt; num) &#123;  // 第一行          boxHeightArr.push(cChild[i].offsetHeight)        &#125;         else &#123;          // 找数组最小值          var minHeight = Math.min(...boxHeightArr)            var minIndex = boxHeightArr.indexOf(minHeight)             // 摆放图片          cChild[i].style.position = &#x27;absolute&#x27;          cChild[i].style.top = minHeight + &#x27;px&#x27;          cChild[i].style.left = cChild[minIndex].offsetLeft + &#x27;px&#x27;            // 更新这一列的高度          boxHeightArr[minIndex] = boxHeightArr[minIndex] + cChild[i].offsetHeight        &#125;      &#125;    &#125;    &#125;\n\nwindow.onload = function() &#123;&#125;js 写在头部，加上这个就不影响了，之后的代码写在里面就可以了；\nimgLocation(&#39;container&#39;, &#39;box&#39;)   运用封装的思维\n.offsetWidth  获取宽度\n.offsetHeight 获取高度\n.offsetLeft   获取距离父元素的左侧距离\n.offsetTop    获取距离父元素的顶部距离\n...boxHeightArr   …是解构数组的操作\nindexof(arr)      会返回数组的下标\n","slug":"瀑布流","date":"2024-11-22T06:12:20.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"b78b732595416811105ff8bbead66711","title":"前端通信 CustomEvent","content":"通过简单的几行代码，我们能够轻松创建和触发自定义事件，从而降低特殊场景下的开发风险，并且提升我们的开发效率。而且它可以非常容易的写到 React 和 Vue 项目中，\n实现过程看看如何利用 CustomEvent 构建一个全局广播推送消息的机制：\n1234567// 创建并触发自定义事件const customEvent = w(&#x27;yourEventName&#x27;, &#123;    detail: &#123; key: &#x27;myKey&#x27;, value: &#x27;newValue&#x27;&#125; // 自定义数据&#125;); window.dispatchEvent(customEvent); // 推送消息\n\n我们需要设置接收端：\n1234567// 监听自定义事件window.addEventListener(&#x27;yourEventName&#x27;, (event) =&gt; &#123;  const &#123; key, value &#125; = event.detail;  if (key === &#x27;myKey&#x27;) &#123;    console.log(&#x27;Detected localStorage change:&#x27;, value);  &#125;&#125;);\n\nVue 组件之间进行通信12345678910111213141516171819202122232425&lt;template&gt;  &lt;div&gt;    &lt;input v-model=&quot;username&quot; @input=&quot;updateUser&quot; placeholder=&quot;Enter your name&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      username: &#x27;&#x27;,    &#125;;  &#125;,  methods: &#123;    updateUser() &#123;      // 创建并触发自定义事件      const customEvent = new CustomEvent(&#x27;userUpdated&#x27;, &#123;        detail: &#123; name: this.username &#125;,      &#125;);      window.dispatchEvent(customEvent);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\nNotification.vue\n1234567891011121314151617181920212223&lt;template&gt;  &lt;div v-if=&quot;message&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;&#x27;,    &#125;;  &#125;,  mounted() &#123;    window.addEventListener(&#x27;userUpdated&#x27;, (event) =&gt; &#123;      const &#123; name &#125; = event.detail;      this.message = `User name has been changed to $&#123;name&#125;`;    &#125;);  &#125;,  beforeDestroy() &#123;    window.removeEventListener(&#x27;userUpdated&#x27;, this.eventListener);  &#125;,&#125;;&lt;/script&gt;\n\n","slug":"前端通信 CustomEvent","date":"2024-11-08T06:39:50.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"权栈"},{"id":"4a2d58310807e71f37ee94ffca6e1c5d","title":"在 Vue 中实现20MB图片上传压缩到10KB","content":"在现代 Web 应用中，文件上传是一个常见的功能，尤其是在用户需要上传图片时。然而，上传的文件往往会占用较大的存储空间，影响性能和用户体验。因此，限制文件大小是一个重要的需求。在这篇文章中，我们将介绍如何在 Vue.js 应用中实现文件上传，并将上传压缩到 10KB\n创建文件上传组件我们首先需要创建一个简单的文件上传组件，用户可以通过这个组件选择图片文件。以下是基本的组件结构：\n123456&lt;template&gt;  &lt;div&gt;    &lt;input type=&quot;file&quot; @change=&quot;handleFileUpload&quot; accept=&quot;image/*&quot; /&gt;    &lt;img v-if=&quot;imageSrc&quot; :src=&quot;imageSrc&quot; alt=&quot;Preview&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;\n\n这个模板包含一个文件输入框和一个用于显示图片预览的 img 标签。\n处理文件上传接下来，我们需要在组件中定义文件上传的逻辑。我们将使用 FileReader API 来读取文件，并通过 canvas 进行图片的压缩处理。\n123456789101112131415&lt;script&gt;export default &#123;  data() &#123;    return &#123;      imageSrc: null,    &#125;;  &#125;,  methods: &#123;    async handleFileUpload(event) &#123;      const file = event.target.files[0];      if (file) &#123;        const compressedFile = await this.compressImage(file);        console.log(compressedFile);      &#125;    &#125;,\n\nhandleFileUpload 方法会在用户选择文件后被调用。我们首先检查用户是否选择了文件，如果选择了，则调用 compressImage 方法进行压缩处理。\n压缩图片压缩图片的核心逻辑在于 compressImage 方法。该方法会创建一个新的 canvas 元素，并根据最大宽高对图片进行缩放，然后将其压缩到 10KB 以内。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849      compressImage(file) &#123;      return new Promise((resolve, reject) =&gt; &#123;        const reader = new FileReader();        reader.onload = (e) =&gt; &#123;          const img = new Image();          img.src = e.target.result;          img.onload = () =&gt; &#123;            const canvas = document.createElement(&#x27;canvas&#x27;);            const ctx = canvas.getContext(&#x27;2d&#x27;);            const MAX_WIDTH = 100; // 最大宽度            const MAX_HEIGHT = 100; // 最大高度            let width = img.width;            let height = img.height;            // 计算新的宽高            if (width &gt; height) &#123;              if (width &gt; MAX_WIDTH) &#123;                height *= MAX_WIDTH / width;                width = MAX_WIDTH;              &#125;            &#125; else &#123;              if (height &gt; MAX_HEIGHT) &#123;                width *= MAX_HEIGHT / height;                height = MAX_HEIGHT;              &#125;            &#125;            canvas.width = width;            canvas.height = height;            ctx.drawImage(img, 0, 0, width, height);            // 压缩为 10KB            canvas.toBlob((blob) =&gt; &#123;              if (blob.size &gt; 10 * 1024) &#123; // 10KB                reject(new Error(&#x27;Compressed file exceeds 10KB.&#x27;));              &#125; else &#123;                resolve(blob);                this.imageSrc = URL.createObjectURL(blob); // 显示预览              &#125;            &#125;, &#x27;image/jpeg&#x27;, 0.7); // 设定压缩质量          &#125;;        &#125;;        reader.readAsDataURL(file);      &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\n在这个方法中，我们首先读取文件并创建一个图像对象。在图像加载完成后，我们创建一个 canvas，设置其大小，并将图像绘制到画布上。接下来，我们使用 canvas.toBlob 方法将画布内容转换为 Blob 对象，并检查其大小是否小于 10KB。如果压缩成功，我们将 Blob 对象转换为 URL 以供预览。\n预览与用户反馈在处理完文件上传和压缩后，我们可以通过绑定 imageSrc 来显示上传后的图片预览。这样用户就可以实时查看他们上传的文件。\n1&lt;img v-if=&quot;imageSrc&quot; :src=&quot;imageSrc&quot; alt=&quot;Preview&quot; /&gt;\n\n总结通过以上步骤，我们成功创建了一个简单的文件上传组件，能够有效地限制上传文件的大小为 10KB。这种处理方式不仅能保证上传的文件符合大小要求，同时也能在一定程度上保证上传的速度和用户体验。\n如果你需要支持其他类型的文件或者扩展更多功能，可以根据实际需求对代码进行相应的修改。这种方法也可以作为其他文件处理功能的基础，帮助你在 Vue 应用中实现更复杂的文件上传逻辑。\n","slug":"在 Vue 中实现文件上传并限制文件大小为 10KB","date":"2024-11-01T06:02:00.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"权栈"},{"id":"322d11b057e8d3400060738444344655","title":"Vue3源码——render函数","content":"在了解vue render函数之前, 需要先了解下Vue的整体流程\n应该可以理解一个Vue组件是如何运行起来的.\n\n模板通过编译生成AST树\nAST树生成Vue的render渲染函数\nrender渲染函数结合数据生成vNode(Virtual DOM Node)树\nDiff和Patch后生新的UI界面(真实DOM渲染)\n\n我们需要了解以下几个概念:\n\n模板, Vue模板是纯HTML, 基于Vue的模板语法, 可以比较方便的处理数据和UI界面的关系\nAST, 即Abstract Syntax Tree的简称, Vue将HTML模板解析为AST,并对AST进行一些优化的标记处理, 提取最大的静态树,以使Virtual DOM直接跳过后面的Diff\nrender渲染函数, render渲染函数是用来生成Virtual DOM的. Vue推荐使用模板来构建我们的应用程序, 在底层实现中Vue最终还是会将模板编译成渲染函数. 因此, 若我们想要得到更好的控制, 可以直接写渲染函数.(重点)\nVirtual DOM, 虚拟DOM\nWatcher, 每个Vue组件都有一个对应的watcher, 它会在组件render时收集组件所依赖的数据, 并在依赖有更新时, 触发组件重新渲染, Vue会自动优化并更新需要更新DOM\n\n.vue单文件的实现12345678910111213141516171819202122232425262728293031&lt;template&gt;    &lt;h1 v-if=&quot;level === 1&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h1&gt;    &lt;h2 v-else-if=&quot;level === 2&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h2&gt;    &lt;h3 v-else-if=&quot;level === 3&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h3&gt;    &lt;h4 v-else-if=&quot;level === 4&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h4&gt;    &lt;h5 v-else-if=&quot;level === 5&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h5&gt;    &lt;h6 v-else-if=&quot;level === 6&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h6&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;anchored-heading&#x27;,  props: &#123;        level: &#123;            type: Number,            required: true        &#125;    &#125;&#125;&lt;/script&gt;\n\nrender函数的实现123456789101112131415Vue.component(&#x27;anchored-heading&#x27;, &#123;    render: function (createElement) &#123;        return createElement(            &#x27;h&#x27; + this.level,   // tag name 标签名称            this.$slots.default // 子组件中的阵列        )    &#125;,    props: &#123;        level: &#123;            type: Number,            required: true        &#125;    &#125;&#125;)\n\ncreateElement解析过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104const SIMPLE_NORMALIZE = 1const ALWAYS_NORMALIZE = 2function createElement (context, tag, data, children, normalizationType, alwaysNormalize) &#123;    // 兼容不传data的情况    if (Array.isArray(data) || isPrimitive(data)) &#123;        normalizationType = children        children = data        data = undefined    &#125;    // 如果alwaysNormalize是true    // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值    if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE        // 调用_createElement创建虚拟节点        return _createElement(context, tag, data, children, normalizationType)    &#125;    function _createElement (context, tag, data, children, normalizationType) &#123;        /**        * 如果存在data.__ob__，说明data是被Observer观察的数据        * 不能用作虚拟节点的data        * 需要抛出警告，并返回一个空节点        *         * 被监控的data不能被用作vnode渲染的数据的原因是：        * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作        */        if (data &amp;&amp; data.__ob__) &#123;            process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(            `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\\n` +            &#x27;Always create fresh vnode data objects in each render!&#x27;,            context            )            return createEmptyVNode()        &#125;        // 当组件的is属性被设置为一个falsy的值        // Vue将不会知道要把这个组件渲染成什么        // 所以渲染一个空节点        if (!tag) &#123;            return createEmptyVNode()        &#125;        // 作用域插槽        if (Array.isArray(children) &amp;&amp; typeof children[0] === &#x27;function&#x27;) &#123;            data = data || &#123;&#125;            data.scopedSlots = &#123; default: children[0] &#125;            children.length = 0        &#125;        // 根据normalizationType的值，选择不同的处理方法        if (normalizationType === ALWAYS_NORMALIZE) &#123;            children = normalizeChildren(children)        &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123;            children = simpleNormalizeChildren(children)        &#125;        let vnode, ns        // 如果标签名是字符串类型        if (typeof tag === &#x27;string&#x27;) &#123;            let Ctor            // 获取标签名的命名空间            ns = config.getTagNamespace(tag)            // 判断是否为保留标签            if (config.isReservedTag(tag)) &#123;                // 如果是保留标签,就创建一个这样的vnode                vnode = new VNode(                    config.parsePlatformTagName(tag), data, children,                    undefined, undefined, context                )                // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义            &#125; else if ((Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123;                // 如果找到了这个标签的定义，就以此创建虚拟组件节点                vnode = createComponent(Ctor, data, context, children, tag)            &#125; else &#123;                // 兜底方案，正常创建一个vnode                vnode = new VNode(                    tag, data, children,                    undefined, undefined, context                )            &#125;        // 当tag不是字符串的时候，我们认为tag是组件的构造类        // 所以直接创建        &#125; else &#123;            vnode = createComponent(tag, data, context, children)        &#125;        // 如果有vnode        if (vnode) &#123;            // 如果有namespace，就应用下namespace，然后返回vnode            if (ns) applyNS(vnode, ns)            return vnode        // 否则，返回一个空节点        &#125; else &#123;            return createEmptyVNode()        &#125;    &#125;&#125;\n\n","slug":"Vue3源码——render函数","date":"2024-10-18T07:25:50.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"c86a81eebdde1918fe7712218383ec84","title":"Vue3源码——h函数","content":"Vue和React这类框架比起远古时期的jQuery，最大的改变就是采用了MVVM架构。\n而MVVM架构的核心，则是虚拟DOM。\n基本概念虚拟DOM说到虚拟DOM，先得说起真实DOM。真实的DOM就是一颗HTML树，里面包含了节点、属性（class、id、style等）、子节点信息。\n例如这样的DOM节点\n1&lt;div id=&quot;app&quot; class=&quot;test&quot;&gt;hello world&lt;/div&gt;\n\n虚拟的DOM也要包括和真实DOM一样的信息。区别在于，它用JS对象来表示\n例如刚才的DOM节点，用JS可以这样表示\n12345678const vnode = &#123;    type: &quot;div&quot;,    props: &#123;        id: &quot;app&quot;,        class: &quot;test&quot;    &#125;,    children: &quot;hello world&quot;&#125;\n\n可以看出，这个vnode对象，用了type、props和children分别表示了这个真实DOM节点的类型（div）、属性（id为app，class为test）以及子节点（字符串hello world）。看着这样格式的JS对象，我们也可以很容易地推理得到一个真实的DOM节点。我们把这样的一个对象称之为虚拟DOM。\nh函数在Vue源码中，虚拟DOM是由h函数生成的。生成时同样可以传入节点类型、属性以及子节点信息。\n1h(&quot;div&quot;, &#123; id: &quot;app&quot;, class: &quot;test&quot; &#125;, &quot;hello world&quot;)\n\n尝试打印这个h函数生成的vnode，内部信息比较丰富，用注释标注了一些核心的属性\n1234567891011121314151617181920212223242526272829303132&#123;        // 是否是VNode对象        &quot;__v_isVNode&quot;: true,        &quot;__v_skip&quot;: true,        // 节点类型        &quot;type&quot;: &quot;div&quot;,        // 节点属性        &quot;props&quot;: &#123; &quot;class&quot;: &quot;test&quot;, &quot;id&quot;: &quot;app&quot; &#125;,        &quot;key&quot;: null,        &quot;ref&quot;: null,        &quot;scopeId&quot;: null,        &quot;slotScopeIds&quot;: null,        // 子节点        &quot;children&quot;: &quot;hello world&quot;,        &quot;component&quot;: null,        &quot;suspense&quot;: null,        &quot;ssContent&quot;: null,        &quot;ssFallback&quot;: null,        &quot;dirs&quot;: null,        &quot;transition&quot;: null,        &quot;el&quot;: null,        &quot;anchor&quot;: null,        &quot;target&quot;: null,        &quot;targetAnchor&quot;: null,        &quot;staticCount&quot;: 0,        &quot;shapeFlag&quot;: 9,        &quot;patchFlag&quot;: 0,        &quot;dynamicProps&quot;: null,        &quot;dynamicChildren&quot;: null,        &quot;appContext&quot;: null&#125;\n\nh函数框架基本框架对于h函数，我们知道应该包括三个参数\n\n节点类型type\n属性props（可选）\n子节点children（可选）\n\n考虑到属性和子节点都是可选参数，因此要针对入参数量和类型做一些判断，大概的规则如下\n12345678910111213141516171819202122232425export function h(type: any, propsOrChildren?: any, children?: any): VNode &#123;  const l = arguments.length;  // 两个参数，不知道是props没传还是children没传  if (l == 2) &#123;    if (isObject(propsOrChildren) &amp;&amp; !isArray(propsOrChildren)) &#123;      if (isVNode(propsOrChildren)) &#123;        return createVNode(type, null, [propsOrChildren]);      &#125;      return createVNode(type, propsOrChildren, []);    &#125; else &#123;      return createVNode(type, null, propsOrChildren);    &#125;  &#125; else &#123;    // 三个及以上的参数，肯定是props和children都有    if (l &gt; 3) &#123;      children = Array.prototype.slice.call(arguments, 2);    &#125; else if (l === 3 &amp;&amp; isVNode(children)) &#123;      children = [children];    &#125;    return createVNode(type, propsOrChildren, children);  &#125;&#125;\n\n至于是否为vnode的判断，直接根据__v_isVNode属性就可得知\n123export function isVNode(value: any): value is VNode &#123;  return value ? value.__v_isVNode === true : false;&#125;\n\n整体框架出来了，接下来vnode的生成，主要就是createVNode这个方法了\nvnode的类型关于DOM节点，我们大概可以分成这样一些类别\n\n标准节点：div、h1等常规标签\n注释节点\nFragment节点\n组件\n……\n\n那么，相对的，vnode也会区分一些节点类型。\n查看Vue源码可以得知，里面包含了文本节点Text、片段节点Fragment、DOM节点Element、组件节点Component、注释节点Comment等等。\n此外，对于children来说，可能是一个，也可能是数组，甚至是对象、函数等等多种不同类型。\n源码中，为了区分不同的节点，使用了shapeFlag，而且这个值还用二进制位进行计算。\n123456789101112131415161718192021222324252627282930export const enum ShapeFlags &#123;  /**   * type = Element   */  ELEMENT = 1,  /**   * 函数组件   */  FUNCTIONAL_COMPONENT = 1 &lt;&lt; 1,  /**   * 有状态（响应数据）组件   */  STATEFUL_COMPONENT = 1 &lt;&lt; 2,  /**   * children = Text   */  TEXT_CHILDREN = 1 &lt;&lt; 3,  /**   * children = Array   */  ARRAY_CHILDREN = 1 &lt;&lt; 4,  /**   * children = slot   */  SLOTS_CHILDREN = 1 &lt;&lt; 5,  /**   * 组件：有状态（响应数据）组件 | 函数组件   */  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT,&#125;\n\nh函数实现element节点+文本childrenh函数最简单的用法是创建一个有tag名称的节点，子节点是文本。\n1const vnode = h(&quot;div&quot;, &quot;hello world&quot;);\n\n为了实现VNode的构建，需要先构建createVNode方法，接收type、props、children这三个参数。\n123456789101112131415export interface VNode &#123;  __v_isVNode: true  type: any  props: any  children: any  shapeFlag: number&#125;export function createVNode(type, props, children): VNode &#123;  // 这里先处理文本类型，其他的shapeFlag先不处理  const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0;    return createBaseVNode(type, props, children, shapeFlag);&#125;\n\n生成了shapeFlag后，要先创建VNode的一些基本属性，源码中用的就是createBaseVNode方法，并且在这之后使用normalizeChildren标准化children的类型（即使用位或运算得到一个shapeFlag值）\n123456789101112131415161718192021222324252627282930313233// 创建基础vnodefunction createBaseVNode(type, props, children, shapeFlag) &#123;  const vnode = &#123;    __v_isVNode: true,    type,    props,    shapeFlag,  &#125; as VNode;  normalizeChildren(vnode, children);  return vnode;&#125;function normalizeChildren(vnode: VNode, children: unknown) &#123;  let type = 0;  if (children === null) &#123;    children = null;  &#125; else if (isArray(children)) &#123;    // TODO: 数组类型children处理  &#125; else if (typeof children === &quot;object&quot;) &#123;    // TODO: 对象类型的children处理  &#125; else if (isFunction(children)) &#123;    // TODO: 函数类型的children处理  &#125; else &#123;    children = String(children);    type = ShapeFlags.TEXT_CHILDREN;  &#125;  vnode.children = children;  vnode.shapeFlag |= type;&#125;\n\n此时我们可以通过h函数拿到tag为string（例如div、p等），且children内容是text的vnode值了，和源码的核心内容是一致的\n123const vnode = h(&quot;div&quot;, &quot;hello world&quot;);console.log(vnode); // shapeFlag是9，children是hello world\n\nelement节点+数组children相比于上一个节点类型，这个的区别就是children不再是一个节点，而是多个\n1const vnode = h(&quot;div&quot;, [h(&quot;p&quot;, &quot;p1&quot;), h(&quot;p&quot;, &quot;p2&quot;), h(&quot;p&quot;, &quot;p3&quot;)]);\n\n其中每一个节点的解析就是刚才element+text这种组合，而且这几个节点会先被处理成VNode，唯一的区别是整体div这个节点\n查看源码可以知道，我们只需要在最后生成div的VNode的时候提供一个type数值就行\n123456789function normalizeChildren(vnode: VNode, children: unknown) &#123;  ......  else if (isArray(children)) &#123;    type = ShapeFlags.ARRAY_CHILDREN;  &#125;    ......&#125;\n\n这时候这个VNode的打印结果就和源码核心一致了\n123const vnode = h(&quot;div&quot;, [h(&quot;p&quot;, &quot;p1&quot;), h(&quot;p&quot;, &quot;p2&quot;), h(&quot;p&quot;, &quot;p3&quot;)]);console.log(vnode); // shapeFlag是17，children也是vnode节点，shapeFlag都是9\n\n从这里不难发现，VNode中一个很关键的属性是shapeFlag，正如名字一样，它描述了虚拟DOM节点的形状，而这个形状包括了父节点类型和子节点类型&#x2F;形状，其中：\n\ncreateBaseVNode：提供了父节点的类型\nnormalizeChildren：提供了子节点的类型和形状\n\n组件Component首先要明确一个问题：在Vue中，组件的本质是对象&#x2F;函数\n所以实际上在Vue中写的组件，如果需要渲染的话，要用对象包裹，其中包含一个render方法\n12345678910const component = &#123;  render() &#123;    const vnode1 = h(&quot;div&quot;, &quot;this is component&quot;);    return vnode1;  &#125;,&#125;;const vnode2 = h(component);render(vnode2, document.querySelector(&#x27;#app&#x27;));\n\n按照之前的h函数实现和理解，其实我们可以在component的render中直接返回一个VNode对象，render方法直接给一个VNode对象，也能达到一样的效果，主要的注意点就是shapeFlag值要保持和源码一致\n12345678910111213141516const component = &#123;  render() &#123;    return &#123;      v__is_vnode: true,      type: &quot;div&quot;,      children: &quot;this is component&quot;,      shapeFlag: 9    &#125;  &#125;&#125;render(&#123;  v__is_vnode: true,  type: component,  shapeFlag: 4&#125;, document.querySelector(&#x27;#app&#x27;));\n\n所以只需要注意处理一下type和shapeFlag值，就可以完成组件component的h函数了，只要在createVNode中修改一行即可\n12345678910function createVNode(type, props, children): VNode &#123;  ......  const shapeFlag = isString(type)    ? ShapeFlags.ELEMENT    : isObject(type)    ? ShapeFlags.STATEFUL_COMPONENT    : 0;  ......&#125;\n\n按照之前的代码，最后生成的VNode里的children会变成”undefined”，其实是normalizeChildren里面的判断条件过于严苛了，把===改成==即可\n1234567function normalizeChildren(vnode: VNode, children: unknown) &#123;  ......  if (children == null) &#123;    children = null;  &#125;  ......&#125;\n\n其他一些简单节点这里的简单节点包括：\n\n纯文本Text\n注释Comment\n片段Fragment\n\n查看源码可以发现，用h函数构建的这些节点的type都是Symbol类型，shapeFlag都是8\n12345const vnodeText = h(Text, &quot;this is text&quot;);const vnodeComment = h(Comment, &quot;this is comment&quot;);const vnodeFragment = h(Fragment, &quot;this is fragment&quot;);\n\n相比于之前的代码，我们只需要考虑type的问题，这里直接创建几个常量处理即可\n123export const Fragment = Symbol(&quot;Fragment&quot;);export const Text = Symbol(&quot;Text&quot;);export const Comment = Symbol(&quot;Comment&quot;);\n\n处理完之后，h函数对这些简单节点的输出就和源码核心保持一致了\nclass和style的增强处理Vue中对class和style，支持使用数组&#x2F;对象，动态绑定值\n12345const vnode = h(&#x27;div&#x27;, &#123;  class: &#123;    &#x27;red&#x27;: true  &#125;&#125;, &#x27;improve class&#x27;);\n\n按照上面的代码，可以拿到一个带有class为red的div\n阅读源码得知，这个增强处理需要添加一个normalizeClass方法，方法本质上也是对class对象做一个遍历，针对string&#x2F;array&#x2F;object做不同的处理方式，最后拼接成string\n123456789101112131415161718192021222324252627282930313233function normalizeClass(value: unknown): string &#123;  let res = &quot;&quot;;  if (isString(value)) &#123;    res = value;  &#125; else if (isArray(value)) &#123;    for (let i = 0; i &lt; value.length; i++) &#123;      const normalized = normalizeClass(value[i]);      if (normalized) &#123;        res += normalized + &quot; &quot;;      &#125;    &#125;  &#125; else if (isObject(value)) &#123;    for (const name in value as object) &#123;      if ((value as object)[name]) &#123;        res += name + &quot; &quot;;      &#125;    &#125;  &#125;  return res.trim();&#125;function createVNode(type, props, children): VNode &#123;  if (props) &#123;    let &#123; class: klass, style &#125; = props;    if (klass &amp;&amp; !isString(klass)) &#123;      props.class = normalizeClass(klass);    &#125;  &#125;  ......&#125;\n\nstyle的处理逻辑上和class一致\n","slug":"Vue3源码——h函数","date":"2024-10-12T06:57:10.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"a4c1e6f4a7d260a2971f3f08fe46eea6","title":"Vue3.5 useId","content":"useId的作用他的作用也是生成唯一ID，同一个Vue应用里面每次调用useId生成的ID都不同。\n使用方法也很简单，代码如下：\n123456789101112&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useId &#125; from &#x27;vue&#x27;const id0 = useId();console.log(id0); // v-0const id1 = useId();console.log(id1); // v-1const id2 = useId();console.log(id2); // v-2&lt;/script&gt;\n\nuseId是如何实现的来看看useId的源码，非常简单！！简化后的代码如下：\n12345678function useId(): string &#123;  const i = getCurrentInstance()  if (i) &#123;    return (i.appContext.config.idPrefix || &#x27;v&#x27;) + &#x27;-&#x27; + i.ids[0] + i.ids[1]++  &#125;  return &#x27;&#x27;&#125;\n\n总结生成的ID分为三部分：\n\n第一部分为前缀：app.config.idPrefix，如果没有配置，那么就是字符串v。\n\n第二部分字符串：-。\n\n第三部分的值为一个自增的数字，存在vue实例上面的ids属性，所有的vue实例上面的ids属性都是指向同一个数组。这也就是为什么说useId可以在Vue应用内生成唯一的ID，而不是在Vue组件内生成唯一的ID。\n\n\n","slug":"Vue3.5 useId","date":"2024-09-27T07:14:20.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"56ce95bec0e493691d1f055dfbf1898e","title":"前端优化首次加载速度","content":"compression-webpack-plugincompression-webpack-plugin 是一个 Webpack 插件，用于压缩生成的静态文件，通常是使用 Gzip 或 Brotli 压缩格式。这有助于减小文件大小，从而提高网页加载速度和性能。\nclean-webpack-pluginclean-webpack-plugin 是一个 Webpack 插件，用于在每次构建前自动清理输出目录（如 dist 文件夹），以确保新构建的文件是最新的，避免遗留旧文件。\nterser-webpack-pluginterser-webpack-plugin 是一个 Webpack 插件，用于压缩和混淆 JavaScript 代码，通常在生产环境中使用。它基于 Terser 工具，能够有效地减少 JavaScript 文件的体积，从而提高网页加载速度。\nhtml-webpack-pluginhtml-webpack-plugin 是一个 Webpack 插件，用于简化生成 HTML 文件的过程，通常用于将打包的 JavaScript 和 CSS 文件自动注入到 HTML 模板中。\n@vue&#x2F;preload-webpack-plugin@vue&#x2F;preload-webpack-plugin 是一个 Webpack 插件，主要用于优化 Vue 应用的资源加载性能。它可以自动添加  标签到生成的 HTML 文件中，以便浏览器预加载关键资源（如 JavaScript 和 CSS 文件）。\nvue.config 文件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172const path = require(&quot;path&quot;);const px2rem = require(&quot;postcss-px2rem&quot;);const postcss = px2rem(&#123;  remUnit: 37.5, // 基准大小 baseSize，需要和rem.js中相同&#125;);let productionGzipExtensions = /\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$/i;const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;); // 用于在每次构建前清理 /dist 文件夹const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); // 用于压缩 JavaScript 代码const &#123; BundleAnalyzerPlugin &#125; = require(&quot;webpack-bundle-analyzer&quot;); //const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const PreloadPlugin = require(&quot;@vue/preload-webpack-plugin&quot;);require(&quot;events&quot;).EventEmitter.defaultMaxListeners = 0;module.exports = &#123;  // 路径前缀  publicPath: process.env.VUE_APP_PUBLICPATH,  assetsDir: &quot;static&quot;,  // 是否启用 eslint-loader 在保存时检查代码  lintOnSave: true,  // 是否生成 source map 文件，生产环境可以关闭以提升打包速度  productionSourceMap: process.env.NODE_ENV == &quot;development&quot;,  // 扩展 webpack-chain 配置，进一步优化 Webpack 配置  chainWebpack: (config) =&gt; &#123;    // 忽略的打包文件    config.externals(&#123;      vue: &quot;Vue&quot;,      &quot;vue-router&quot;: &quot;VueRouter&quot;,      vuex: &quot;Vuex&quot;,      axios: &quot;axios&quot;,      &quot;element-ui&quot;: &quot;ELEMENT&quot;,    &#125;);    // 配置入口文件    const entry = config.entry(&quot;app&quot;);    entry.add(&quot;babel-polyfill&quot;).end();    entry.add(&quot;classlist-polyfill&quot;).end();    entry.add(&quot;@/mock&quot;).end();    // // 配置预加载和预取，优化加载性能    // config.plugin(&quot;preload&quot;).tap((options) =&gt; &#123;    //   options[0].fileBlacklist.push(/\\.map$/, /hot-update\\.js$/);    //   return options;    // &#125;);    // 移除 prefetch 插件，避免加载不必要的资源    // config.plugins.delete(&quot;prefetch&quot;);  &#125;,  // 配置 Webpack  configureWebpack: (config) =&gt; &#123;    const plugins = [      new CleanWebpackPlugin(),      new HtmlWebpackPlugin(&#123;        filename: &quot;index.html&quot;,        template: &quot;public/index.html&quot;,        inject: true,        templateParameters: &#123;          BASE_URL: &quot;/&quot;, // 传递 BASE_URL 到模板        &#125;,      &#125;),      new PreloadPlugin(&#123;        rel: &quot;preload&quot;,        include: &quot;initial&quot;,        fileBlacklist: [/\\.map$/, /hot-update\\.js$/, /vendor\\..*\\.js$/],        // 根据需要进行更多配置      &#125;),    ];    if (      process.env.NODE_ENV === &quot;production&quot; ||      process.env.NODE_ENV === &quot;test&quot;    ) &#123;      plugins.push(        new CompressionPlugin(&#123;          filename: &quot;[path][base].gz&quot;,          algorithm: &quot;gzip&quot;,          test: productionGzipExtensions,          threshold: 10240,          minRatio: 0.8,          deleteOriginalAssets: false,          // exclude: /(cdn|util)\\/.*\\.(js|css|json|txt|html|ico|svg)$/i,        &#125;),        new BundleAnalyzerPlugin(&#123;          analyzerMode: &quot;static&quot;,          reportFilename: &quot;bundle-report.html&quot;,          openAnalyzer: true,        &#125;)      );      config.optimization = &#123;        minimize: true,        minimizer: [          new TerserPlugin(&#123;            terserOptions: &#123;              compress: &#123;                drop_console: true,                drop_debugger: true,              &#125;,              output: &#123;                comments: false,              &#125;,            &#125;,            parallel: true,          &#125;),        ],        splitChunks: &#123;          // Uncomment this block if needed          chunks: &quot;all&quot;,          maxInitialRequests: 5,          minSize: 30000,          maxSize: 250000,          cacheGroups: &#123;            vendor: &#123;              test: /[\\\\/]node_modules[\\\\/]/,              name(module) &#123;                const packageName = module.context.match(                  /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/                )[1];                return `npm.$&#123;packageName.replace(&quot;@&quot;, &quot;&quot;)&#125;`;              &#125;,              priority: -10,            &#125;,            common: &#123;              name: &quot;common&quot;,              minChunks: 2,              priority: -20,              reuseExistingChunk: true,              chunks: &quot;all&quot;,            &#125;,          &#125;,        &#125;,      &#125;;    &#125; else if (process.env.NODE_ENV === &quot;development&quot;) &#123;      config.devtool = &quot;source-map&quot;;    &#125;    config.plugins.push(...plugins);  &#125;,  css: &#123;    extract: &#123; ignoreOrder: true &#125;,    loaderOptions: &#123;      postcss: &#123;        plugins: [postcss],      &#125;,    &#125;,  &#125;,  transpileDependencies: [&quot;ol&quot;],  // 开发模式反向代理配置，生产模式请使用Nginx部署并配置反向代理  devServer: &#123;    port: 1888,    proxy: &#123;      &quot;/api&quot;: &#123;        // 本地服务接口地址        target: process.env.VUE_APP_BASE_API_COMMON_URL,        // 远程演示服务地址, 可用于直接启动项目        // target: &#x27;https://saber.bladex.vip/api&#x27;,        ws: true,        pathRewrite: &#123;          &quot;^/api&quot;: &quot;/&quot;,        &#125;,      &#125;,    &#125;,  &#125;,  // 通过环境变量控制是否启用性能提示  //  performance: &#123;  //   hints: (process.env.NODE_ENV === &#x27;production&#x27; || process.env.NODE_ENV === &#x27;test&#x27;) ? &#x27;warning&#x27; : false  // &#125;&#125;;\n\n修改测试环境配置NODE_ENV 是一个环境变量，用于指示 Node.js 应用程序的运行环境。它通常有三个主要值： development 、 production 和 test 。\n只有 production 生成环境才会压缩文件 如果是 NODE_ENV&#x3D;test 改成 NODE_ENV&#x3D;production\n\n修改动态路由懒加载方式\n加载时机：\nrequire：同步加载，运行时决定。\nimport：异步加载，编译时确定。\n\n\n作用域：\nrequire：在模块内部，作用域较封闭。\nimport：支持命名导入和默认导入，灵活性更高。\n\n\n环境：\nrequire：主要用于 Node.js。\nimport：适用于现代浏览器和支持 ES6 的环境。\n\n\n\n\n","slug":"前端优化首次加载速度","date":"2024-09-20T07:08:20.000Z","categories_index":"Vue2","tags_index":"Vue2","author_index":"权栈"},{"id":"d5edacab67506b18e45fcb0990be9618","title":"前端大屏自适应方案","content":"易用 🚀调用仅需一行代码，即可适配设置分辨率以下的所有屏幕，无需任何其他辅助\n性能 ⚡只影响一个元素样式，计算量极小\n灵活 💥可以给项目全局自适应，也可以单独页面做自适应\n原理即在 scale 等比缩放的基础上，获取屏幕的宽度除以设计稿的宽度，获取到宽度比例值；获取屏幕的高度除以设计稿的高度，获取到高度比例值；使用 transform: scale(x, x) 动态监听来实现页面的缩放比例，从而还原 UI 图效果。这可以支持设计稿以下的各种分辨率。\n使用代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* 根据视口尺寸调整给定元素的缩放比例。 * @param &#123;HTMLElement&#125; e - 要调整的元素。 * @param &#123;number&#125; planWidth - 元素的计划宽度,默认1980px。 * @param &#123;number&#125; planHeight - 元素的计划高度,默认1080px。 */    function selfAdaption(e, planWidth = 1980, planHeight = 1080) &#123;      /**       * 获取客户端视口的当前尺寸，并根据最小计划尺寸进行调整。       * @returns &#123;&#123;width: number, height: number&#125;&#125; 客户端视口的调整后宽度和高度。       */      console.log(planWidth, planHeight);      const getClientDimensions = () =&gt; &#123;        // 获取客户端视口的当前宽度和高度        let width = document.body.clientWidth || document.documentElement.clientWidth;        let height = document.body.clientHeight || document.documentElement.clientHeight;        // 如果计划高度小于1080，则进行高度调整        if (planHeight &lt; 1080) &#123;          height -= (1080 - planHeight);        &#125;        // 如果计划宽度小于1920，则进行宽度调整        if (planWidth &lt; 1920) &#123;          width -= (1920 - planWidth);        &#125;        return &#123; width, height &#125;;      &#125;;      /**       * 根据当前视口尺寸更新元素的缩放比例。       */      const updateScale = () =&gt; &#123;        // 获取调整后的客户端尺寸        const &#123; width, height &#125; = getClientDimensions();        // 计算宽度和高度的缩放比例        const ratioWidth = width / planWidth;        const ratioHeight = height / planHeight;        // 对元素应用缩放变换        e.style.transform = `scale($&#123;ratioWidth&#125;, $&#123;ratioHeight&#125;)`;      &#125;;      // 设置元素的初始样式      e.style.cssText += `    transform-origin: 0 0 0;    display: flex;    min-width: auto;    min-height: auto;    overflow: hidden;    width: $&#123;planWidth&#125;px;    height: $&#123;planHeight&#125;px;  `;      // 初始更新缩放比例      updateScale();      // 添加事件监听器，在窗口调整大小时更新缩放比例      window.addEventListener(&#x27;resize&#x27;, updateScale);    &#125;selfAdaption（e）传递的要自适应最外层dom\n\n\n\n\n\n\n\n\n\n\n使用 transform: scale 自适应后，地图上点击事件失效，解决办法：\n12345678910resetMapSize() &#123;        let mapContent = document.getElementById(&quot;map&quot;);        mapContent.style.transform = `scale($&#123;1 / ratioWidth&#125;,$&#123;1 / ratioHeight&#125;)`      &#125;  // 用完后记得销毁监听事件 比如 vue 中  destroyed () &#123;      window.removeEventListener(&#x27;resize&#x27;,this.resetMapSize)    &#125; \n","slug":"前端大屏自适应方案","date":"2024-09-12T02:58:20.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"32c8c23c6d89385feba3d0e7e602221c","title":"Vue3.5 源码解析， useTemplateRef 实现原理","content":"useTemplateRef 的作用useTemplateRef 是用来专门获取 dom 或者 组件示例 的。\n在之前，如果我们想要获取 dom ，那么需要这么做：\n\n先为 dom 指定 ref 属性，并且给定一个 value 值\n\n在 js 中，声明 value 值的变量，并且给定初始值为 空的 ref\n12345678910&lt;script setup&gt;// 首先，您定义了一个值为undefined或空的ref// 并以您想要的方式命名生成的可用内容const divEl = ref();&lt;/script&gt;&lt;template&gt;&lt;!-- 然后使用与“ref”属性的值相同的名称,在模板中的某个地方 --&gt;&lt;div ref=&quot;divEl&quot; &gt;&lt;/div&gt;&lt;/template&gt;\n\n但是，这种方案存在一个问题，那就是：ref 通常用来声明响应式数据。当 ref 不光作为响应式声明，还被作为 dom 实例的时候，那么就难免有点让人疑惑了。\n所以在（3.5 之后） Vue 推出了一个新的 API 叫做 useTemplateRef 来解决这个问题：\n123456789101112131415&lt;template&gt; &lt;div&gt;  &lt;div ref=&quot;el&quot;&gt;程序员Sunday&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted, useTemplateRef &#125; from &#x27;vue&#x27;const elRef = useTemplateRef(&#x27;el&#x27;)onMounted(() =&gt; &#123; console.log(elRef.value) // dom 示例&#125;)&lt;/script&gt;\n\nuseTemplateRef 的实现原理1234567891011121314export function useTemplateRef(key: Keys) &#123;  const i = getCurrentInstance();  const r = shallowRef(null);  if (i) &#123;    const refs = i.refs === EMPTY_OBJ ? (i.refs = &#123;&#125;) : i.refs;    Object.defineProperty(refs, key, &#123;      enumerable: true,      get: () =&gt; r.value,      set: (val) =&gt; (r.value = val),    &#125;);  &#125;  return r;&#125;\n\n第一个 i：通过 getCurrentInstance() 获取，得到的是 上下文实例。​ 接下来，通过 i.refs 获取到所有的 ref 数据，然后为 refs 添加 Object.defineProperty 的监听，监听的属性名就是入参 key。如果以 useTemplateRef(‘el’) 为例，那么就是 “el”。\n通过监听对应 key 的 get 和 set 标记，这里 重点关注 set 标记，在这里为 r.value 进行了赋值，即：r.value &#x3D; val。这里的 val 就是 refs[key] 的值，也就是对应的 ref 组件实例。\n第二个 r：通过 shallowRef(null) 获取，作为返回值r 作为 useTemplateRef 的返回值即 最终获取的组件示例。\n","slug":"Vue3.5 源码解析， useTemplateRef 实现原理","date":"2024-09-06T06:07:04.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"c34479c7fc43ef2eede71b250f18b4aa","title":"ref和reactive原理","content":"refref 的处理上就是先将基本类型转换成对象类型，然后在里面加入一个 this._v_isRef 的布尔类型的值，来判断它是不是被 ref 处理了，然后将上面写的 track 和 trigger 函数写入 get 和 set 函数里面，如果你要处理的是一个对象，那么 vue3 就会把它改成 reactive 的处理方式。所以说，ref 可以处理基本类型和引用类型，而 reactive 处理的是引用类型，二者的区别不是很大。\nreactive\n首先我们取一个对象{a: 1}\n\n然后调用封装好的 reactive 函数 const state &#x3D; reactive({a: 1})\n\n这个时候就会进入代码片段 1.1 里面的 reactive 函数，在进入 createReactiveObject 函数\n\n然后就会对我们要代理的对象进行判断，如果是对象的话就继续下去\n\n在判断我们是不是已经代理过这个对象（就是我们预先空出一个位置，将已经代理过的对象全部存储下来），代理过就返回代理后的值，没有的话就创建一个新的代理\n\n再然后绑定上 proxy 函数里面的 get 和 set 回调函数（可以看到代码 1.2）\n\n\n","slug":"ref和reactive原理","date":"2024-08-27T08:30:20.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"2e839452302506867eaaf60fd116d0d6","title":"vue3 Api","content":"defineProps()和 defineEmits()\nv-model:childValueModel 修改了值 本来应该是 modeValue\ndefineEmites() 使用要添加 update:\n1&lt;defineModelChild v-model;childValueModel=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;\n\n​\n123456789&lt;template&gt;&lt;div&gt;&#123;&#123; childValueModel &#125;&#125;&lt;/div&gt;&lt;button @click=&quot;myEmits(&#x27;update:childValueModel&#x27;, childValueModel + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const myProps = defineProps([&#x27;childValueModel&#x27;]);const myEmits= defineEmits([&#x27;update:childValueModel&#x27;]);&lt;/script&gt;\n\n父组件\n12345678910111213&lt;script setup&gt;import HelloWorld from &#x27;./components/defineProps-----defineEmits .vue&#x27;//父组件function count(value) &#123;  console.log(value);&#125;&lt;/script&gt;&lt;template&gt;  &lt;HelloWorld a=&quot;qwdqwd&quot;    @count=&#x27;count&#x27; /&gt;&lt;/template&gt;\n\n子组件\n1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;//子组件let count = ref(0)let emit = defineEmits([&quot;count&quot;])const props = defineProps((&#123;  a: String&#125;))function increment() &#123;  count.value++  emit(&quot;count&quot;, count.value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125; &#123;&#123;props.a&#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\ndefineModel() 3.4+版本\ndefineModel 其实也是一个语法糖，是对 v-model 再包装的语法糖\ndefineModel 帮你获取到了 prop 中的 modelValue ，且当 值发生变化时，会自动帮你调用 update:modelValue\n123456const myProps = defineProps([&quot;modelValue&quot;]);const myEmits = defineEmits([&quot;update:modelValue&quot;]);// 说白了，这里的 modelValue 等价于 props.modelValue + emit(&#x27;update:modelValue&#x27;)// defineModel 帮你 封装了 modelValue 和 update:modelValueconst modelValue = defineModel();\n\n父组件\n12345678910&lt;template&gt;  &lt;defineModelChild v-model=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import defineModelChild from &#x27;./components/defineModelChild.vue&#x27;;const childValue = ref(0);&lt;/script&gt;\n\nv-model 子组件\n1234567891011&lt;template&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;myEmits(&#x27;update:modelValue&#x27;, modelValue + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;defineProps([&#x27;modelValue&#x27;]);const myEmits = defineEmits([&#x27;update:modelValue&#x27;]);&lt;/script&gt;\n\ndefineModel() 子组件\n12345678&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;modelValue++&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const modelValue = defineModel();&lt;/script&gt;\n\ndefineExpose 子传父\n（用在子组件，暴露想传递的值或方法，父组件通过 ref 属性获取子组件暴露的）\n使用 script setup 的组件是默认关闭的——即通过模板引用或者 $parent 链获取到的组件的公开实例，不会暴露任何在 script setup 中声明的绑定。\n那么，通过 defineExpose 编译器宏来显式指定在\n然后，父组件通过 ref 属性访问子组件\n父组件：\n123456789101112131415161718&lt;Index ref=&quot;childeRef&quot;&gt;&lt;/Index&gt;&lt;script setup&gt;    import Index from &quot;./index.vue&quot;;    const childeRef = ref();    function test() &#123;        console.log(childeRef.value.msg) // Hello World    &#125;    onMounted(() =&gt; &#123;      let flag:boolean = true;      let value:number= 5;      childeRef.value.childFn(flag,value) // 调用子组件函数, 输出 6    &#125;)&lt;/script&gt;\n\n子组件：\n1234567891011121314151617&lt;script setup&gt;    import &#123;ref&#125; from &quot;vue&quot;;    function childFn(type：boolean, data：number) &#123;        console.log(&#x27;我是子组件&#x27;);        if(data)&#123;           let value = data + 1;           return value;        &#125;    &#125;    const msg = &#x27;Hello World&#x27;;    defineExpose(&#123; //暴露想要传递的值或方法        msg,        childFn,    &#125;);&lt;/script&gt;\n\ndefineOptions 3.3+\n123456789&lt;script setup&gt;import &#123; defineOptions &#125; from &#x27;vue&#x27;defineOptions(&#123;name: &#x27;Foo&#x27;,//组件重命名 inheritAttrs: false,//...更多自定义属性&#125;)&lt;/script&gt;\n\ncomputed 计算属性\n1234567891011121314151617181920212223&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123; publishedBooksMessage &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\ncomputed 传参\n12345678910111213141516171819202122232425262728&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  name: &#x27;John Doe&#x27;,  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return function (value) &#123;    console.log(value)    return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Has published books:&lt;/p&gt;    &#123;&#123; publishedBooksMessage(12) &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatch 监听\n默认开启深度监听\n123456789101112131415161718192021222324252627282930&lt;script setup &gt;import &#123; ref, watch &#125; from &quot;vue&quot;const count = ref(0)const btnClick = () =&gt; &#123;  count.value++;&#125;// ✅ 方法一，传递响应对象watch(count, (newValue, oldValue) =&gt; &#123;  console.log(newValue, oldValue)&#125;)// ❌ 方法二：传递响应对象下的属性watch(user.name, (value) =&gt; &#123;    console.log(value) // 监听失败，没输出&#125;)// ✅ 方法三：传递函数，函数返回响应对象属性watch(() =&gt; user.name, (value) =&gt; &#123;    console.log(value); // 监听成功，输出 jake&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123; count &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatchEffect 的使用\nwatchEffect 也是一个帧听器，是一个副作用函数。 它会监听引用数据类型的所有属性，不需要具体到某个属性，一旦运行就会立即监听，组件卸载的时候会停止监听。\n123456789101112131415161718192021222324&lt;script setup &gt;import &#123; reactive, ref, watch, watchEffect &#125; from &quot;vue&quot;const count = reactive(&#123; name: &#x27;112&#x27;, data: [&quot;你好&quot;] &#125;)const btnClick = () =&gt; &#123;  count.data[0] = &#x27;被改了&#x27;&#125;watchEffect(() =&gt; &#123;  console.log(count.data[0]);&#125;) watch([count,obj],() =&gt; &#123;      console.log(&#x27;监听的多个数据改变了&#x27;)    &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123;count.data[0]&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nstopWatchEffect 停止监听\n1234567const stop = watchEffect(() =&gt; &#123;  console.log(&quot;name:&quot;, obj.name);&#125;);const stopWatchEffect = () =&gt; &#123;  console.log(&quot;停止监听&quot;);  stop();&#125;;\n\nonInvalidate 函数 解决执行顺序乱的问题\n","slug":"vue3 Api","date":"2024-06-13T08:39:58.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"}]