[{"id":"32c8c23c6d89385feba3d0e7e602221c","title":"Vue3.5 源码解析， useTemplateRef 实现原理","content":"useTemplateRef 的作用useTemplateRef 是用来专门获取 dom 或者 组件示例 的。\n在之前，如果我们想要获取 dom ，那么需要这么做：\n\n先为 dom 指定 ref 属性，并且给定一个 value 值\n\n在 js 中，声明 value 值的变量，并且给定初始值为 空的 ref\n12345678910&lt;script setup&gt;// 首先，您定义了一个值为undefined或空的ref// 并以您想要的方式命名生成的可用内容const divEl = ref();&lt;/script&gt;&lt;template&gt;&lt;!-- 然后使用与“ref”属性的值相同的名称,在模板中的某个地方 --&gt;&lt;div ref=&quot;divEl&quot; &gt;&lt;/div&gt;&lt;/template&gt;\n\n但是，这种方案存在一个问题，那就是：ref 通常用来声明响应式数据。当 ref 不光作为响应式声明，还被作为 dom 实例的时候，那么就难免有点让人疑惑了。\n所以在（3.5 之后） Vue 推出了一个新的 API 叫做 useTemplateRef 来解决这个问题：\n123456789101112131415&lt;template&gt; &lt;div&gt;  &lt;div ref=&quot;el&quot;&gt;程序员Sunday&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted, useTemplateRef &#125; from &#x27;vue&#x27;const elRef = useTemplateRef(&#x27;el&#x27;)onMounted(() =&gt; &#123; console.log(elRef.value) // dom 示例&#125;)&lt;/script&gt;\n\nuseTemplateRef 的实现原理1234567891011121314export function useTemplateRef(key: Keys) &#123;  const i = getCurrentInstance();  const r = shallowRef(null);  if (i) &#123;    const refs = i.refs === EMPTY_OBJ ? (i.refs = &#123;&#125;) : i.refs;    Object.defineProperty(refs, key, &#123;      enumerable: true,      get: () =&gt; r.value,      set: (val) =&gt; (r.value = val),    &#125;);  &#125;  return r;&#125;\n\n第一个 i：通过 getCurrentInstance() 获取，得到的是 上下文实例。​ 接下来，通过 i.refs 获取到所有的 ref 数据，然后为 refs 添加 Object.defineProperty 的监听，监听的属性名就是入参 key。如果以 useTemplateRef(‘el’) 为例，那么就是 “el”。\n通过监听对应 key 的 get 和 set 标记，这里 重点关注 set 标记，在这里为 r.value 进行了赋值，即：r.value &#x3D; val。这里的 val 就是 refs[key] 的值，也就是对应的 ref 组件实例。\n第二个 r：通过 shallowRef(null) 获取，作为返回值r 作为 useTemplateRef 的返回值即 最终获取的组件示例。\n","slug":"Vue3.5 源码解析， useTemplateRef 实现原理","date":"2024-09-06T06:07:04.000Z","categories_index":"","tags_index":"Vue3","author_index":"权栈"},{"id":"c34479c7fc43ef2eede71b250f18b4aa","title":"ref和reactive原理","content":"refref 的处理上就是先将基本类型转换成对象类型，然后在里面加入一个 this._v_isRef 的布尔类型的值，来判断它是不是被 ref 处理了，然后将上面写的 track 和 trigger 函数写入 get 和 set 函数里面，如果你要处理的是一个对象，那么 vue3 就会把它改成 reactive 的处理方式。所以说，ref 可以处理基本类型和引用类型，而 reactive 处理的是引用类型，二者的区别不是很大。\nreactive\n首先我们取一个对象{a: 1}\n\n然后调用封装好的 reactive 函数 const state &#x3D; reactive({a: 1})\n\n这个时候就会进入代码片段 1.1 里面的 reactive 函数，在进入 createReactiveObject 函数\n\n然后就会对我们要代理的对象进行判断，如果是对象的话就继续下去\n\n在判断我们是不是已经代理过这个对象（就是我们预先空出一个位置，将已经代理过的对象全部存储下来），代理过就返回代理后的值，没有的话就创建一个新的代理\n\n再然后绑定上 proxy 函数里面的 get 和 set 回调函数（可以看到代码 1.2）\n\n\n","slug":"ref和reactive原理","date":"2024-08-27T08:30:20.000Z","categories_index":"","tags_index":"Vue3","author_index":"权栈"},{"id":"2e839452302506867eaaf60fd116d0d6","title":"vue3 Api","content":"defineProps()和 defineEmits()\nv-model:childValueModel 修改了值 本来应该是 modeValue\ndefineEmites() 使用要添加 update:\n1&lt;defineModelChild v-model;childValueModel=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;\n\n​\n123456789&lt;template&gt;&lt;div&gt;&#123;&#123; childValueModel &#125;&#125;&lt;/div&gt;&lt;button @click=&quot;myEmits(&#x27;update:childValueModel&#x27;, childValueModel + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const myProps = defineProps([&#x27;childValueModel&#x27;]);const myEmits= defineEmits([&#x27;update:childValueModel&#x27;]);&lt;/script&gt;\n\n父组件\n12345678910111213&lt;script setup&gt;import HelloWorld from &#x27;./components/defineProps-----defineEmits .vue&#x27;//父组件function count(value) &#123;  console.log(value);&#125;&lt;/script&gt;&lt;template&gt;  &lt;HelloWorld a=&quot;qwdqwd&quot;    @count=&#x27;count&#x27; /&gt;&lt;/template&gt;\n\n子组件\n1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;//子组件let count = ref(0)let emit = defineEmits([&quot;count&quot;])const props = defineProps((&#123;  a: String&#125;))function increment() &#123;  count.value++  emit(&quot;count&quot;, count.value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125; &#123;&#123;props.a&#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\ndefineModel() 3.4+版本\ndefineModel 其实也是一个语法糖，是对 v-model 再包装的语法糖\ndefineModel 帮你获取到了 prop 中的 modelValue ，且当 值发生变化时，会自动帮你调用 update:modelValue\n123456const myProps = defineProps([&quot;modelValue&quot;]);const myEmits = defineEmits([&quot;update:modelValue&quot;]);// 说白了，这里的 modelValue 等价于 props.modelValue + emit(&#x27;update:modelValue&#x27;)// defineModel 帮你 封装了 modelValue 和 update:modelValueconst modelValue = defineModel();\n\n父组件\n12345678910&lt;template&gt;  &lt;defineModelChild v-model=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import defineModelChild from &#x27;./components/defineModelChild.vue&#x27;;const childValue = ref(0);&lt;/script&gt;\n\nv-model 子组件\n1234567891011&lt;template&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;myEmits(&#x27;update:modelValue&#x27;, modelValue + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;defineProps([&#x27;modelValue&#x27;]);const myEmits = defineEmits([&#x27;update:modelValue&#x27;]);&lt;/script&gt;\n\ndefineModel() 子组件\n12345678&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;modelValue++&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const modelValue = defineModel();&lt;/script&gt;\n\ndefineExpose 子传父\n（用在子组件，暴露想传递的值或方法，父组件通过 ref 属性获取子组件暴露的）\n使用 script setup 的组件是默认关闭的——即通过模板引用或者 $parent 链获取到的组件的公开实例，不会暴露任何在 script setup 中声明的绑定。\n那么，通过 defineExpose 编译器宏来显式指定在\n然后，父组件通过 ref 属性访问子组件\n父组件：\n123456789101112131415161718&lt;Index ref=&quot;childeRef&quot;&gt;&lt;/Index&gt;&lt;script setup&gt;    import Index from &quot;./index.vue&quot;;    const childeRef = ref();    function test() &#123;        console.log(childeRef.value.msg) // Hello World    &#125;    onMounted(() =&gt; &#123;      let flag:boolean = true;      let value:number= 5;      childeRef.value.childFn(flag,value) // 调用子组件函数, 输出 6    &#125;)&lt;/script&gt;\n\n子组件：\n1234567891011121314151617&lt;script setup&gt;    import &#123;ref&#125; from &quot;vue&quot;;    function childFn(type：boolean, data：number) &#123;        console.log(&#x27;我是子组件&#x27;);        if(data)&#123;           let value = data + 1;           return value;        &#125;    &#125;    const msg = &#x27;Hello World&#x27;;    defineExpose(&#123; //暴露想要传递的值或方法        msg,        childFn,    &#125;);&lt;/script&gt;\n\ndefineOptions 3.3+\n123456789&lt;script setup&gt;import &#123; defineOptions &#125; from &#x27;vue&#x27;defineOptions(&#123;name: &#x27;Foo&#x27;,//组件重命名 inheritAttrs: false,//...更多自定义属性&#125;)&lt;/script&gt;\n\ncomputed 计算属性\n1234567891011121314151617181920212223&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123; publishedBooksMessage &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\ncomputed 传参\n12345678910111213141516171819202122232425262728&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  name: &#x27;John Doe&#x27;,  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return function (value) &#123;    console.log(value)    return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Has published books:&lt;/p&gt;    &#123;&#123; publishedBooksMessage(12) &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatch 监听\n默认开启深度监听\n123456789101112131415161718192021222324252627282930&lt;script setup &gt;import &#123; ref, watch &#125; from &quot;vue&quot;const count = ref(0)const btnClick = () =&gt; &#123;  count.value++;&#125;// ✅ 方法一，传递响应对象watch(count, (newValue, oldValue) =&gt; &#123;  console.log(newValue, oldValue)&#125;)// ❌ 方法二：传递响应对象下的属性watch(user.name, (value) =&gt; &#123;    console.log(value) // 监听失败，没输出&#125;)// ✅ 方法三：传递函数，函数返回响应对象属性watch(() =&gt; user.name, (value) =&gt; &#123;    console.log(value); // 监听成功，输出 jake&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123; count &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatchEffect 的使用\nwatchEffect 也是一个帧听器，是一个副作用函数。 它会监听引用数据类型的所有属性，不需要具体到某个属性，一旦运行就会立即监听，组件卸载的时候会停止监听。\n123456789101112131415161718192021222324&lt;script setup &gt;import &#123; reactive, ref, watch, watchEffect &#125; from &quot;vue&quot;const count = reactive(&#123; name: &#x27;112&#x27;, data: [&quot;你好&quot;] &#125;)const btnClick = () =&gt; &#123;  count.data[0] = &#x27;被改了&#x27;&#125;watchEffect(() =&gt; &#123;  console.log(count.data[0]);&#125;) watch([count,obj],() =&gt; &#123;      console.log(&#x27;监听的多个数据改变了&#x27;)    &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123;count.data[0]&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nstopWatchEffect 停止监听\n1234567const stop = watchEffect(() =&gt; &#123;  console.log(&quot;name:&quot;, obj.name);&#125;);const stopWatchEffect = () =&gt; &#123;  console.log(&quot;停止监听&quot;);  stop();&#125;;\n\nonInvalidate 函数 解决执行顺序乱的问题\n","slug":"vue3 Api","date":"2024-06-13T08:39:58.000Z","categories_index":"","tags_index":"Vue3","author_index":"权栈"}]