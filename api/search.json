[{"id":"a4c1e6f4a7d260a2971f3f08fe46eea6","title":"Vue3.5 useId","content":"useId的作用他的作用也是生成唯一ID，同一个Vue应用里面每次调用useId生成的ID都不同。\n使用方法也很简单，代码如下：\n123456789101112&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useId &#125; from &#x27;vue&#x27;const id0 = useId();console.log(id0); // v-0const id1 = useId();console.log(id1); // v-1const id2 = useId();console.log(id2); // v-2&lt;/script&gt;\n\nuseId是如何实现的来看看useId的源码，非常简单！！简化后的代码如下：\n12345678function useId(): string &#123;  const i = getCurrentInstance()  if (i) &#123;    return (i.appContext.config.idPrefix || &#x27;v&#x27;) + &#x27;-&#x27; + i.ids[0] + i.ids[1]++  &#125;  return &#x27;&#x27;&#125;\n\n总结生成的ID分为三部分：\n\n第一部分为前缀：app.config.idPrefix，如果没有配置，那么就是字符串v。\n\n第二部分字符串：-。\n\n第三部分的值为一个自增的数字，存在vue实例上面的ids属性，所有的vue实例上面的ids属性都是指向同一个数组。这也就是为什么说useId可以在Vue应用内生成唯一的ID，而不是在Vue组件内生成唯一的ID。\n\n\n","slug":"Vue3.5 useId","date":"2024-09-27T07:14:20.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"56ce95bec0e493691d1f055dfbf1898e","title":"前端优化首次加载速度","content":"compression-webpack-plugincompression-webpack-plugin 是一个 Webpack 插件，用于压缩生成的静态文件，通常是使用 Gzip 或 Brotli 压缩格式。这有助于减小文件大小，从而提高网页加载速度和性能。\nclean-webpack-pluginclean-webpack-plugin 是一个 Webpack 插件，用于在每次构建前自动清理输出目录（如 dist 文件夹），以确保新构建的文件是最新的，避免遗留旧文件。\nterser-webpack-pluginterser-webpack-plugin 是一个 Webpack 插件，用于压缩和混淆 JavaScript 代码，通常在生产环境中使用。它基于 Terser 工具，能够有效地减少 JavaScript 文件的体积，从而提高网页加载速度。\nhtml-webpack-pluginhtml-webpack-plugin 是一个 Webpack 插件，用于简化生成 HTML 文件的过程，通常用于将打包的 JavaScript 和 CSS 文件自动注入到 HTML 模板中。\n@vue&#x2F;preload-webpack-plugin@vue&#x2F;preload-webpack-plugin 是一个 Webpack 插件，主要用于优化 Vue 应用的资源加载性能。它可以自动添加  标签到生成的 HTML 文件中，以便浏览器预加载关键资源（如 JavaScript 和 CSS 文件）。\nvue.config 文件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172const path = require(&quot;path&quot;);const px2rem = require(&quot;postcss-px2rem&quot;);const postcss = px2rem(&#123;  remUnit: 37.5, // 基准大小 baseSize，需要和rem.js中相同&#125;);let productionGzipExtensions = /\\.(js|css|json|txt|html|ico|svg)(\\?.*)?$/i;const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;); // 用于在每次构建前清理 /dist 文件夹const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); // 用于压缩 JavaScript 代码const &#123; BundleAnalyzerPlugin &#125; = require(&quot;webpack-bundle-analyzer&quot;); //const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const PreloadPlugin = require(&quot;@vue/preload-webpack-plugin&quot;);require(&quot;events&quot;).EventEmitter.defaultMaxListeners = 0;module.exports = &#123;  // 路径前缀  publicPath: process.env.VUE_APP_PUBLICPATH,  assetsDir: &quot;static&quot;,  // 是否启用 eslint-loader 在保存时检查代码  lintOnSave: true,  // 是否生成 source map 文件，生产环境可以关闭以提升打包速度  productionSourceMap: process.env.NODE_ENV == &quot;development&quot;,  // 扩展 webpack-chain 配置，进一步优化 Webpack 配置  chainWebpack: (config) =&gt; &#123;    // 忽略的打包文件    config.externals(&#123;      vue: &quot;Vue&quot;,      &quot;vue-router&quot;: &quot;VueRouter&quot;,      vuex: &quot;Vuex&quot;,      axios: &quot;axios&quot;,      &quot;element-ui&quot;: &quot;ELEMENT&quot;,    &#125;);    // 配置入口文件    const entry = config.entry(&quot;app&quot;);    entry.add(&quot;babel-polyfill&quot;).end();    entry.add(&quot;classlist-polyfill&quot;).end();    entry.add(&quot;@/mock&quot;).end();    // // 配置预加载和预取，优化加载性能    // config.plugin(&quot;preload&quot;).tap((options) =&gt; &#123;    //   options[0].fileBlacklist.push(/\\.map$/, /hot-update\\.js$/);    //   return options;    // &#125;);    // 移除 prefetch 插件，避免加载不必要的资源    // config.plugins.delete(&quot;prefetch&quot;);  &#125;,  // 配置 Webpack  configureWebpack: (config) =&gt; &#123;    const plugins = [      new CleanWebpackPlugin(),      new HtmlWebpackPlugin(&#123;        filename: &quot;index.html&quot;,        template: &quot;public/index.html&quot;,        inject: true,        templateParameters: &#123;          BASE_URL: &quot;/&quot;, // 传递 BASE_URL 到模板        &#125;,      &#125;),      new PreloadPlugin(&#123;        rel: &quot;preload&quot;,        include: &quot;initial&quot;,        fileBlacklist: [/\\.map$/, /hot-update\\.js$/, /vendor\\..*\\.js$/],        // 根据需要进行更多配置      &#125;),    ];    if (      process.env.NODE_ENV === &quot;production&quot; ||      process.env.NODE_ENV === &quot;test&quot;    ) &#123;      plugins.push(        new CompressionPlugin(&#123;          filename: &quot;[path][base].gz&quot;,          algorithm: &quot;gzip&quot;,          test: productionGzipExtensions,          threshold: 10240,          minRatio: 0.8,          deleteOriginalAssets: false,          // exclude: /(cdn|util)\\/.*\\.(js|css|json|txt|html|ico|svg)$/i,        &#125;),        new BundleAnalyzerPlugin(&#123;          analyzerMode: &quot;static&quot;,          reportFilename: &quot;bundle-report.html&quot;,          openAnalyzer: true,        &#125;)      );      config.optimization = &#123;        minimize: true,        minimizer: [          new TerserPlugin(&#123;            terserOptions: &#123;              compress: &#123;                drop_console: true,                drop_debugger: true,              &#125;,              output: &#123;                comments: false,              &#125;,            &#125;,            parallel: true,          &#125;),        ],        splitChunks: &#123;          // Uncomment this block if needed          chunks: &quot;all&quot;,          maxInitialRequests: 5,          minSize: 30000,          maxSize: 250000,          cacheGroups: &#123;            vendor: &#123;              test: /[\\\\/]node_modules[\\\\/]/,              name(module) &#123;                const packageName = module.context.match(                  /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/                )[1];                return `npm.$&#123;packageName.replace(&quot;@&quot;, &quot;&quot;)&#125;`;              &#125;,              priority: -10,            &#125;,            common: &#123;              name: &quot;common&quot;,              minChunks: 2,              priority: -20,              reuseExistingChunk: true,              chunks: &quot;all&quot;,            &#125;,          &#125;,        &#125;,      &#125;;    &#125; else if (process.env.NODE_ENV === &quot;development&quot;) &#123;      config.devtool = &quot;source-map&quot;;    &#125;    config.plugins.push(...plugins);  &#125;,  css: &#123;    extract: &#123; ignoreOrder: true &#125;,    loaderOptions: &#123;      postcss: &#123;        plugins: [postcss],      &#125;,    &#125;,  &#125;,  transpileDependencies: [&quot;ol&quot;],  // 开发模式反向代理配置，生产模式请使用Nginx部署并配置反向代理  devServer: &#123;    port: 1888,    proxy: &#123;      &quot;/api&quot;: &#123;        // 本地服务接口地址        target: process.env.VUE_APP_BASE_API_COMMON_URL,        // 远程演示服务地址, 可用于直接启动项目        // target: &#x27;https://saber.bladex.vip/api&#x27;,        ws: true,        pathRewrite: &#123;          &quot;^/api&quot;: &quot;/&quot;,        &#125;,      &#125;,    &#125;,  &#125;,  // 通过环境变量控制是否启用性能提示  //  performance: &#123;  //   hints: (process.env.NODE_ENV === &#x27;production&#x27; || process.env.NODE_ENV === &#x27;test&#x27;) ? &#x27;warning&#x27; : false  // &#125;&#125;;\n\n修改测试环境配置NODE_ENV 是一个环境变量，用于指示 Node.js 应用程序的运行环境。它通常有三个主要值： development 、 production 和 test 。\n只有 production 生成环境才会压缩文件 如果是 NODE_ENV&#x3D;test 改成 NODE_ENV&#x3D;production\n\n修改动态路由懒加载方式\n加载时机：\nrequire：同步加载，运行时决定。\nimport：异步加载，编译时确定。\n\n\n作用域：\nrequire：在模块内部，作用域较封闭。\nimport：支持命名导入和默认导入，灵活性更高。\n\n\n环境：\nrequire：主要用于 Node.js。\nimport：适用于现代浏览器和支持 ES6 的环境。\n\n\n\n\n","slug":"前端优化首次加载速度","date":"2024-09-20T07:08:20.000Z","categories_index":"Vue2","tags_index":"Vue2","author_index":"权栈"},{"id":"d5edacab67506b18e45fcb0990be9618","title":"前端大屏自适应方案","content":"易用 🚀调用仅需一行代码，即可适配设置分辨率以下的所有屏幕，无需任何其他辅助\n性能 ⚡只影响一个元素样式，计算量极小\n灵活 💥可以给项目全局自适应，也可以单独页面做自适应\n原理即在 scale 等比缩放的基础上，获取屏幕的宽度除以设计稿的宽度，获取到宽度比例值；获取屏幕的高度除以设计稿的高度，获取到高度比例值；使用 transform: scale(x, x) 动态监听来实现页面的缩放比例，从而还原 UI 图效果。这可以支持设计稿以下的各种分辨率。\n使用代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* 根据视口尺寸调整给定元素的缩放比例。 * @param &#123;HTMLElement&#125; e - 要调整的元素。 * @param &#123;number&#125; planWidth - 元素的计划宽度,默认1980px。 * @param &#123;number&#125; planHeight - 元素的计划高度,默认1080px。 */    function selfAdaption(e, planWidth = 1980, planHeight = 1080) &#123;      /**       * 获取客户端视口的当前尺寸，并根据最小计划尺寸进行调整。       * @returns &#123;&#123;width: number, height: number&#125;&#125; 客户端视口的调整后宽度和高度。       */      console.log(planWidth, planHeight);      const getClientDimensions = () =&gt; &#123;        // 获取客户端视口的当前宽度和高度        let width = document.body.clientWidth || document.documentElement.clientWidth;        let height = document.body.clientHeight || document.documentElement.clientHeight;        // 如果计划高度小于1080，则进行高度调整        if (planHeight &lt; 1080) &#123;          height -= (1080 - planHeight);        &#125;        // 如果计划宽度小于1920，则进行宽度调整        if (planWidth &lt; 1920) &#123;          width -= (1920 - planWidth);        &#125;        return &#123; width, height &#125;;      &#125;;      /**       * 根据当前视口尺寸更新元素的缩放比例。       */      const updateScale = () =&gt; &#123;        // 获取调整后的客户端尺寸        const &#123; width, height &#125; = getClientDimensions();        // 计算宽度和高度的缩放比例        const ratioWidth = width / planWidth;        const ratioHeight = height / planHeight;        // 对元素应用缩放变换        e.style.transform = `scale($&#123;ratioWidth&#125;, $&#123;ratioHeight&#125;)`;      &#125;;      // 设置元素的初始样式      e.style.cssText += `    transform-origin: 0 0 0;    display: flex;    min-width: auto;    min-height: auto;    overflow: hidden;    width: $&#123;planWidth&#125;px;    height: $&#123;planHeight&#125;px;  `;      // 初始更新缩放比例      updateScale();      // 添加事件监听器，在窗口调整大小时更新缩放比例      window.addEventListener(&#x27;resize&#x27;, updateScale);    &#125;selfAdaption（e）传递的要自适应最外层dom\n\n\n\n\n\n\n\n\n\n\n使用 transform: scale 自适应后，地图上点击事件失效，解决办法：\n12345678910resetMapSize() &#123;        let mapContent = document.getElementById(&quot;map&quot;);        mapContent.style.transform = `scale($&#123;1 / ratioWidth&#125;,$&#123;1 / ratioHeight&#125;)`      &#125;  // 用完后记得销毁监听事件 比如 vue 中  destroyed () &#123;      window.removeEventListener(&#x27;resize&#x27;,this.resetMapSize)    &#125; \n","slug":"前端大屏自适应方案","date":"2024-09-12T02:58:20.000Z","categories_index":"JS","tags_index":"JS","author_index":"权栈"},{"id":"32c8c23c6d89385feba3d0e7e602221c","title":"Vue3.5 源码解析， useTemplateRef 实现原理","content":"useTemplateRef 的作用useTemplateRef 是用来专门获取 dom 或者 组件示例 的。\n在之前，如果我们想要获取 dom ，那么需要这么做：\n\n先为 dom 指定 ref 属性，并且给定一个 value 值\n\n在 js 中，声明 value 值的变量，并且给定初始值为 空的 ref\n12345678910&lt;script setup&gt;// 首先，您定义了一个值为undefined或空的ref// 并以您想要的方式命名生成的可用内容const divEl = ref();&lt;/script&gt;&lt;template&gt;&lt;!-- 然后使用与“ref”属性的值相同的名称,在模板中的某个地方 --&gt;&lt;div ref=&quot;divEl&quot; &gt;&lt;/div&gt;&lt;/template&gt;\n\n但是，这种方案存在一个问题，那就是：ref 通常用来声明响应式数据。当 ref 不光作为响应式声明，还被作为 dom 实例的时候，那么就难免有点让人疑惑了。\n所以在（3.5 之后） Vue 推出了一个新的 API 叫做 useTemplateRef 来解决这个问题：\n123456789101112131415&lt;template&gt; &lt;div&gt;  &lt;div ref=&quot;el&quot;&gt;程序员Sunday&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; onMounted, useTemplateRef &#125; from &#x27;vue&#x27;const elRef = useTemplateRef(&#x27;el&#x27;)onMounted(() =&gt; &#123; console.log(elRef.value) // dom 示例&#125;)&lt;/script&gt;\n\nuseTemplateRef 的实现原理1234567891011121314export function useTemplateRef(key: Keys) &#123;  const i = getCurrentInstance();  const r = shallowRef(null);  if (i) &#123;    const refs = i.refs === EMPTY_OBJ ? (i.refs = &#123;&#125;) : i.refs;    Object.defineProperty(refs, key, &#123;      enumerable: true,      get: () =&gt; r.value,      set: (val) =&gt; (r.value = val),    &#125;);  &#125;  return r;&#125;\n\n第一个 i：通过 getCurrentInstance() 获取，得到的是 上下文实例。​ 接下来，通过 i.refs 获取到所有的 ref 数据，然后为 refs 添加 Object.defineProperty 的监听，监听的属性名就是入参 key。如果以 useTemplateRef(‘el’) 为例，那么就是 “el”。\n通过监听对应 key 的 get 和 set 标记，这里 重点关注 set 标记，在这里为 r.value 进行了赋值，即：r.value &#x3D; val。这里的 val 就是 refs[key] 的值，也就是对应的 ref 组件实例。\n第二个 r：通过 shallowRef(null) 获取，作为返回值r 作为 useTemplateRef 的返回值即 最终获取的组件示例。\n","slug":"Vue3.5 源码解析， useTemplateRef 实现原理","date":"2024-09-06T06:07:04.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"c34479c7fc43ef2eede71b250f18b4aa","title":"ref和reactive原理","content":"refref 的处理上就是先将基本类型转换成对象类型，然后在里面加入一个 this._v_isRef 的布尔类型的值，来判断它是不是被 ref 处理了，然后将上面写的 track 和 trigger 函数写入 get 和 set 函数里面，如果你要处理的是一个对象，那么 vue3 就会把它改成 reactive 的处理方式。所以说，ref 可以处理基本类型和引用类型，而 reactive 处理的是引用类型，二者的区别不是很大。\nreactive\n首先我们取一个对象{a: 1}\n\n然后调用封装好的 reactive 函数 const state &#x3D; reactive({a: 1})\n\n这个时候就会进入代码片段 1.1 里面的 reactive 函数，在进入 createReactiveObject 函数\n\n然后就会对我们要代理的对象进行判断，如果是对象的话就继续下去\n\n在判断我们是不是已经代理过这个对象（就是我们预先空出一个位置，将已经代理过的对象全部存储下来），代理过就返回代理后的值，没有的话就创建一个新的代理\n\n再然后绑定上 proxy 函数里面的 get 和 set 回调函数（可以看到代码 1.2）\n\n\n","slug":"ref和reactive原理","date":"2024-08-27T08:30:20.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"},{"id":"2e839452302506867eaaf60fd116d0d6","title":"vue3 Api","content":"defineProps()和 defineEmits()\nv-model:childValueModel 修改了值 本来应该是 modeValue\ndefineEmites() 使用要添加 update:\n1&lt;defineModelChild v-model;childValueModel=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;\n\n​\n123456789&lt;template&gt;&lt;div&gt;&#123;&#123; childValueModel &#125;&#125;&lt;/div&gt;&lt;button @click=&quot;myEmits(&#x27;update:childValueModel&#x27;, childValueModel + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const myProps = defineProps([&#x27;childValueModel&#x27;]);const myEmits= defineEmits([&#x27;update:childValueModel&#x27;]);&lt;/script&gt;\n\n父组件\n12345678910111213&lt;script setup&gt;import HelloWorld from &#x27;./components/defineProps-----defineEmits .vue&#x27;//父组件function count(value) &#123;  console.log(value);&#125;&lt;/script&gt;&lt;template&gt;  &lt;HelloWorld a=&quot;qwdqwd&quot;    @count=&#x27;count&#x27; /&gt;&lt;/template&gt;\n\n子组件\n1234567891011121314151617&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;//子组件let count = ref(0)let emit = defineEmits([&quot;count&quot;])const props = defineProps((&#123;  a: String&#125;))function increment() &#123;  count.value++  emit(&quot;count&quot;, count.value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125; &#123;&#123;props.a&#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\ndefineModel() 3.4+版本\ndefineModel 其实也是一个语法糖，是对 v-model 再包装的语法糖\ndefineModel 帮你获取到了 prop 中的 modelValue ，且当 值发生变化时，会自动帮你调用 update:modelValue\n123456const myProps = defineProps([&quot;modelValue&quot;]);const myEmits = defineEmits([&quot;update:modelValue&quot;]);// 说白了，这里的 modelValue 等价于 props.modelValue + emit(&#x27;update:modelValue&#x27;)// defineModel 帮你 封装了 modelValue 和 update:modelValueconst modelValue = defineModel();\n\n父组件\n12345678910&lt;template&gt;  &lt;defineModelChild v-model=&quot;childValue&quot;&gt;&lt;/defineModelChild&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import defineModelChild from &#x27;./components/defineModelChild.vue&#x27;;const childValue = ref(0);&lt;/script&gt;\n\nv-model 子组件\n1234567891011&lt;template&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;myEmits(&#x27;update:modelValue&#x27;, modelValue + 1)&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;defineProps([&#x27;modelValue&#x27;]);const myEmits = defineEmits([&#x27;update:modelValue&#x27;]);&lt;/script&gt;\n\ndefineModel() 子组件\n12345678&lt;template&gt;  &lt;div&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;modelValue++&quot;&gt;数据 + 1&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const modelValue = defineModel();&lt;/script&gt;\n\ndefineExpose 子传父\n（用在子组件，暴露想传递的值或方法，父组件通过 ref 属性获取子组件暴露的）\n使用 script setup 的组件是默认关闭的——即通过模板引用或者 $parent 链获取到的组件的公开实例，不会暴露任何在 script setup 中声明的绑定。\n那么，通过 defineExpose 编译器宏来显式指定在\n然后，父组件通过 ref 属性访问子组件\n父组件：\n123456789101112131415161718&lt;Index ref=&quot;childeRef&quot;&gt;&lt;/Index&gt;&lt;script setup&gt;    import Index from &quot;./index.vue&quot;;    const childeRef = ref();    function test() &#123;        console.log(childeRef.value.msg) // Hello World    &#125;    onMounted(() =&gt; &#123;      let flag:boolean = true;      let value:number= 5;      childeRef.value.childFn(flag,value) // 调用子组件函数, 输出 6    &#125;)&lt;/script&gt;\n\n子组件：\n1234567891011121314151617&lt;script setup&gt;    import &#123;ref&#125; from &quot;vue&quot;;    function childFn(type：boolean, data：number) &#123;        console.log(&#x27;我是子组件&#x27;);        if(data)&#123;           let value = data + 1;           return value;        &#125;    &#125;    const msg = &#x27;Hello World&#x27;;    defineExpose(&#123; //暴露想要传递的值或方法        msg,        childFn,    &#125;);&lt;/script&gt;\n\ndefineOptions 3.3+\n123456789&lt;script setup&gt;import &#123; defineOptions &#125; from &#x27;vue&#x27;defineOptions(&#123;name: &#x27;Foo&#x27;,//组件重命名 inheritAttrs: false,//...更多自定义属性&#125;)&lt;/script&gt;\n\ncomputed 计算属性\n1234567891011121314151617181920212223&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123; publishedBooksMessage &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\ncomputed 传参\n12345678910111213141516171819202122232425262728&lt;script setup &gt;import &#123; computed, reactive &#125; from &quot;vue&quot;;const author = reactive(&#123;  name: &#x27;John Doe&#x27;,  books: [    &#x27;Vue 2 - Advanced Guide&#x27;,    &#x27;Vue 3 - Basic Guide&#x27;,    &#x27;Vue 4 - The Mystery&#x27;  ]&#125;)const publishedBooksMessage = computed(() =&gt; &#123;  return function (value) &#123;    console.log(value)    return author.books.length &gt; 0 ? &#x27; Yes&#x27; : &quot;No&quot;  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Has published books:&lt;/p&gt;    &#123;&#123; publishedBooksMessage(12) &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatch 监听\n默认开启深度监听\n123456789101112131415161718192021222324252627282930&lt;script setup &gt;import &#123; ref, watch &#125; from &quot;vue&quot;const count = ref(0)const btnClick = () =&gt; &#123;  count.value++;&#125;// ✅ 方法一，传递响应对象watch(count, (newValue, oldValue) =&gt; &#123;  console.log(newValue, oldValue)&#125;)// ❌ 方法二：传递响应对象下的属性watch(user.name, (value) =&gt; &#123;    console.log(value) // 监听失败，没输出&#125;)// ✅ 方法三：传递函数，函数返回响应对象属性watch(() =&gt; user.name, (value) =&gt; &#123;    console.log(value); // 监听成功，输出 jake&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123; count &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nwatchEffect 的使用\nwatchEffect 也是一个帧听器，是一个副作用函数。 它会监听引用数据类型的所有属性，不需要具体到某个属性，一旦运行就会立即监听，组件卸载的时候会停止监听。\n123456789101112131415161718192021222324&lt;script setup &gt;import &#123; reactive, ref, watch, watchEffect &#125; from &quot;vue&quot;const count = reactive(&#123; name: &#x27;112&#x27;, data: [&quot;你好&quot;] &#125;)const btnClick = () =&gt; &#123;  count.data[0] = &#x27;被改了&#x27;&#125;watchEffect(() =&gt; &#123;  console.log(count.data[0]);&#125;) watch([count,obj],() =&gt; &#123;      console.log(&#x27;监听的多个数据改变了&#x27;)    &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;btnClick&quot;&gt;点击&lt;/button&gt;    &#123;&#123;count.data[0]&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;style  scoped&gt;&lt;/style&gt;\n\nstopWatchEffect 停止监听\n1234567const stop = watchEffect(() =&gt; &#123;  console.log(&quot;name:&quot;, obj.name);&#125;);const stopWatchEffect = () =&gt; &#123;  console.log(&quot;停止监听&quot;);  stop();&#125;;\n\nonInvalidate 函数 解决执行顺序乱的问题\n","slug":"vue3 Api","date":"2024-06-13T08:39:58.000Z","categories_index":"Vue3","tags_index":"Vue3","author_index":"权栈"}]