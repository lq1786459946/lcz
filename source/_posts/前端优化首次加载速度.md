---
title: 前端优化首次加载速度
date: 2024-09-20 15:08:20
tags: Vue2
categories: Vue2
---

## compression-webpack-plugin

compression-webpack-plugin 是一个 Webpack 插件，用于压缩生成的静态文件，通常是使用 Gzip 或 Brotli 压缩格式。这有助于减小文件大小，从而提高网页加载速度和性能。

## clean-webpack-plugin

clean-webpack-plugin 是一个 Webpack 插件，用于在每次构建前自动清理输出目录（如 dist 文件夹），以确保新构建的文件是最新的，避免遗留旧文件。

## terser-webpack-plugin

terser-webpack-plugin 是一个 Webpack 插件，用于压缩和混淆 JavaScript 代码，通常在生产环境中使用。它基于 Terser 工具，能够有效地减少 JavaScript 文件的体积，从而提高网页加载速度。

## html-webpack-plugin

html-webpack-plugin 是一个 Webpack 插件，用于简化生成 HTML 文件的过程，通常用于将打包的 JavaScript 和 CSS 文件自动注入到 HTML 模板中。

## @vue/preload-webpack-plugin

@vue/preload-webpack-plugin 是一个 Webpack 插件，主要用于优化 Vue 应用的资源加载性能。它可以自动添加 <link rel="preload"> 标签到生成的 HTML 文件中，以便浏览器预加载关键资源（如 JavaScript 和 CSS 文件）。

vue.config 文件

```js
const path = require("path");

const px2rem = require("postcss-px2rem");

const postcss = px2rem({
  remUnit: 37.5, // 基准大小 baseSize，需要和rem.js中相同
});

let productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;
const CompressionPlugin = require("compression-webpack-plugin");
const { CleanWebpackPlugin } = require("clean-webpack-plugin"); // 用于在每次构建前清理 /dist 文件夹
const TerserPlugin = require("terser-webpack-plugin"); // 用于压缩 JavaScript 代码
const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer"); //
const HtmlWebpackPlugin = require("html-webpack-plugin");

const PreloadPlugin = require("@vue/preload-webpack-plugin");
require("events").EventEmitter.defaultMaxListeners = 0;
module.exports = {
  // 路径前缀
  publicPath: process.env.VUE_APP_PUBLICPATH,
  assetsDir: "static",
  // 是否启用 eslint-loader 在保存时检查代码
  lintOnSave: true,

  // 是否生成 source map 文件，生产环境可以关闭以提升打包速度
  productionSourceMap: process.env.NODE_ENV == "development",
  // 扩展 webpack-chain 配置，进一步优化 Webpack 配置
  chainWebpack: (config) => {
    // 忽略的打包文件
    config.externals({
      vue: "Vue",
      "vue-router": "VueRouter",
      vuex: "Vuex",
      axios: "axios",
      "element-ui": "ELEMENT",
    });

    // 配置入口文件
    const entry = config.entry("app");
    entry.add("babel-polyfill").end();
    entry.add("classlist-polyfill").end();
    entry.add("@/mock").end();

    // // 配置预加载和预取，优化加载性能
    // config.plugin("preload").tap((options) => {
    //   options[0].fileBlacklist.push(/\.map$/, /hot-update\.js$/);
    //   return options;
    // });

    // 移除 prefetch 插件，避免加载不必要的资源
    // config.plugins.delete("prefetch");
  },
  // 配置 Webpack
  configureWebpack: (config) => {
    const plugins = [
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        filename: "index.html",
        template: "public/index.html",
        inject: true,
        templateParameters: {
          BASE_URL: "/", // 传递 BASE_URL 到模板
        },
      }),
      new PreloadPlugin({
        rel: "preload",
        include: "initial",
        fileBlacklist: [/\.map$/, /hot-update\.js$/, /vendor\..*\.js$/],
        // 根据需要进行更多配置
      }),
    ];

    if (
      process.env.NODE_ENV === "production" ||
      process.env.NODE_ENV === "test"
    ) {
      plugins.push(
        new CompressionPlugin({
          filename: "[path][base].gz",
          algorithm: "gzip",
          test: productionGzipExtensions,
          threshold: 10240,
          minRatio: 0.8,
          deleteOriginalAssets: false,
          // exclude: /(cdn|util)\/.*\.(js|css|json|txt|html|ico|svg)$/i,
        }),
        new BundleAnalyzerPlugin({
          analyzerMode: "static",
          reportFilename: "bundle-report.html",
          openAnalyzer: true,
        })
      );

      config.optimization = {
        minimize: true,
        minimizer: [
          new TerserPlugin({
            terserOptions: {
              compress: {
                drop_console: true,
                drop_debugger: true,
              },
              output: {
                comments: false,
              },
            },
            parallel: true,
          }),
        ],
        splitChunks: {
          // Uncomment this block if needed
          chunks: "all",
          maxInitialRequests: 5,
          minSize: 30000,
          maxSize: 250000,
          cacheGroups: {
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              name(module) {
                const packageName = module.context.match(
                  /[\\/]node_modules[\\/](.*?)([\\/]|$)/
                )[1];
                return `npm.${packageName.replace("@", "")}`;
              },
              priority: -10,
            },
            common: {
              name: "common",
              minChunks: 2,
              priority: -20,
              reuseExistingChunk: true,
              chunks: "all",
            },
          },
        },
      };
    } else if (process.env.NODE_ENV === "development") {
      config.devtool = "source-map";
    }

    config.plugins.push(...plugins);
  },
  css: {
    extract: { ignoreOrder: true },
    loaderOptions: {
      postcss: {
        plugins: [postcss],
      },
    },
  },
  transpileDependencies: ["ol"],
  // 开发模式反向代理配置，生产模式请使用Nginx部署并配置反向代理
  devServer: {
    port: 1888,
    proxy: {
      "/api": {
        // 本地服务接口地址
        target: process.env.VUE_APP_BASE_API_COMMON_URL,
        // 远程演示服务地址, 可用于直接启动项目
        // target: 'https://saber.bladex.vip/api',
        ws: true,
        pathRewrite: {
          "^/api": "/",
        },
      },
    },
  },
  // 通过环境变量控制是否启用性能提示
  //  performance: {
  //   hints: (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') ? 'warning' : false
  // }
};
```

## 修改测试环境配置

NODE_ENV 是一个环境变量，用于指示 Node.js 应用程序的运行环境。它通常有三个主要值： development 、 production 和 test 。

只有 production 生成环境才会压缩文件 如果是 NODE_ENV=test 改成 NODE_ENV=production

![image.png](https://atlas.pingcode.com/files/public/66ecd3315e0f3412bbbd3efe?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWRfZm9yX3B1YmljX2ltYWdlIjoiNDAyMTgwNDVhZjkzNDg3NTgyMDI5ZjNlZDI2ZjQ3ZmEiLCJ0ZWFtX2Zvcl9wdWJsaWNfaW1hZ2UiOiI2MTZkMmU2MzJhNjgwNWE3NWY4MjAxOTEiLCJpc19pbnRlcm5hbF90b2tlbiI6dHJ1ZSwiaWF0IjoxNzI2ODExNDYwLCJleHAiOjE3MjY4MjIyNjB9.skXyVJPe6TNvhJBiCDJx885ruVH84rnhluZ00YvkFm8)

## 修改动态路由懒加载方式

1. **加载时机**：
   - `require`：同步加载，运行时决定。
   - `import`：异步加载，编译时确定。
2. **作用域**：
   - `require`：在模块内部，作用域较封闭。
   - `import`：支持命名导入和默认导入，灵活性更高。
3. **环境**：
   - `require`：主要用于 Node.js。
   - `import`：适用于现代浏览器和支持 ES6 的环境。

![image.png](https://atlas.pingcode.com/files/public/66ecd4cea95c5fca81a44c17?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWRfZm9yX3B1YmljX2ltYWdlIjoiNDAyMTgwNDVhZjkzNDg3NTgyMDI5ZjNlZDI2ZjQ3ZmEiLCJ0ZWFtX2Zvcl9wdWJsaWNfaW1hZ2UiOiI2MTZkMmU2MzJhNjgwNWE3NWY4MjAxOTEiLCJpc19pbnRlcm5hbF90b2tlbiI6dHJ1ZSwiaWF0IjoxNzI2ODExNDYwLCJleHAiOjE3MjY4MjIyNjB9.skXyVJPe6TNvhJBiCDJx885ruVH84rnhluZ00YvkFm8)
