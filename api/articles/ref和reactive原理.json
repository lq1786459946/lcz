{"title":"ref和reactive原理","uid":"c34479c7fc43ef2eede71b250f18b4aa","slug":"ref和reactive原理","date":"2024-08-27T08:30:20.000Z","updated":"2024-08-27T08:31:48.938Z","comments":true,"path":"api/articles/ref和reactive原理.json","keywords":null,"cover":null,"content":"<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>ref 的处理上就是先将基本类型转换成对象类型，然后在里面加入一个 this._v_isRef 的布尔类型的值，来判断它是不是被 ref 处理了，然后将上面写的 track 和 trigger 函数写入 get 和 set 函数里面，如果你要处理的是一个对象，那么 vue3 就会把它改成 reactive 的处理方式。所以说，ref 可以处理基本类型和引用类型，而 reactive 处理的是引用类型，二者的区别不是很大。</p>\n<h2 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a>reactive</h2><ul>\n<li><p>首先我们取一个对象{a: 1}</p>\n</li>\n<li><p>然后调用封装好的 reactive 函数 const state &#x3D; reactive({a: 1})</p>\n</li>\n<li><p>这个时候就会进入代码片段 1.1 里面的 reactive 函数，在进入 createReactiveObject 函数</p>\n</li>\n<li><p>然后就会对我们要代理的对象进行判断，如果是对象的话就继续下去</p>\n</li>\n<li><p>在判断我们是不是已经代理过这个对象（就是我们预先空出一个位置，将已经代理过的对象全部存储下来），代理过就返回代理后的值，没有的话就创建一个新的代理</p>\n</li>\n<li><p>再然后绑定上 proxy 函数里面的 get 和 set 回调函数（可以看到代码 1.2）</p>\n</li>\n</ul>\n","feature":true,"text":"refref 的处理上就是先将基本类型转换成对象类型，然后在里面加入一个 this._v_isRef 的布尔类型的值，来判断它是不是被 ref 处理了，然后将上...","permalink":"/post/ref和reactive原理","photos":[],"count_time":{"symbolsCount":517,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Vue3","slug":"Vue3","count":3,"path":"api/tags/Vue3.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ref\"><span class=\"toc-text\">ref</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reactive\"><span class=\"toc-text\">reactive</span></a></li></ol>","author":{"name":"权栈","slug":"blog-author","avatar":"https://p6-passport.byteacctimg.com/img/user-avatar/40c734cabc45915e93f17b88134aa761~140x140.awebp","link":"/","description":"成就伟大的唯一途径就是热爱你所做的事情","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Vue3.5 源码解析， useTemplateRef 实现原理","uid":"32c8c23c6d89385feba3d0e7e602221c","slug":"Vue3.5 源码解析， useTemplateRef 实现原理","date":"2024-09-06T06:07:04.000Z","updated":"2024-09-06T06:32:56.010Z","comments":true,"path":"api/articles/Vue3.5 源码解析， useTemplateRef 实现原理.json","keywords":null,"cover":null,"text":"useTemplateRef 的作用useTemplateRef 是用来专门获取 dom 或者 组件示例 的。 在之前，如果我们想要获取 dom ，那么需要这么...","permalink":"/post/Vue3.5 源码解析， useTemplateRef 实现原理","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Vue3","slug":"Vue3","count":3,"path":"api/tags/Vue3.json"}],"author":{"name":"权栈","slug":"blog-author","avatar":"https://p6-passport.byteacctimg.com/img/user-avatar/40c734cabc45915e93f17b88134aa761~140x140.awebp","link":"/","description":"成就伟大的唯一途径就是热爱你所做的事情","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"vue3 Api","uid":"2e839452302506867eaaf60fd116d0d6","slug":"vue3 Api","date":"2024-06-13T08:39:58.000Z","updated":"2024-08-27T09:44:30.693Z","comments":true,"path":"api/articles/vue3 Api.json","keywords":null,"cover":null,"text":"defineProps()和 defineEmits() v-model:childValueModel 修改了值 本来应该是 modeValue define...","permalink":"/post/vue3 Api","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Vue3","slug":"Vue3","count":3,"path":"api/tags/Vue3.json"}],"author":{"name":"权栈","slug":"blog-author","avatar":"https://p6-passport.byteacctimg.com/img/user-avatar/40c734cabc45915e93f17b88134aa761~140x140.awebp","link":"/","description":"成就伟大的唯一途径就是热爱你所做的事情","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}